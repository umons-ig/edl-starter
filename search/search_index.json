{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83c\udf93 EDL: Expertises digitale et logicielle","text":"<p>Bienvenue dans les travaux pratiques d'\u00c9volution et D\u00e9ploiement Logiciel de l'UMONS!</p>"},{"location":"#objectifs-du-cours","title":"\ud83c\udfaf Objectifs du Cours","text":"<p>Ces travaux pratiques vous apprendront les pratiques du d\u00e9veloppement logiciel moderne :</p> <ul> <li>\u2705 Tests automatis\u00e9s (unitaires, int\u00e9gration, E2E)</li> <li>\u2705 CI/CD (Int\u00e9gration et D\u00e9ploiement Continus)</li> <li>\u2705 GitHub Actions (workflows automatis\u00e9s)</li> <li>\u2705 D\u00e9ploiement en production (avec bases de donn\u00e9es r\u00e9elles)</li> <li>\u2705 Bonnes pratiques (TDD, protection de branche, code review)</li> </ul>"},{"location":"#les-3-travaux-pratiques","title":"\ud83d\udcda Les 3 Travaux Pratiques","text":""},{"location":"#tp-1-tests-unitaires-backend-frontend","title":"TP 1 : Tests Unitaires Backend &amp; Frontend","text":"<p>Objectif : Ma\u00eetriser les tests unitaires avec pytest (Python) et Vitest (TypeScript)</p> <p>Ce que vous allez apprendre :</p> <ul> <li>\ud83d\udc0d Tests backend avec pytest et FastAPI</li> <li>\u269b\ufe0f Tests frontend avec Vitest et React</li> <li>\ud83c\udfad Mocking : simuler des API, des bases de donn\u00e9es</li> <li>\u2615 Bonus Java : Tests avec JUnit 4</li> </ul> <p>Technologies : <code>Python</code> \u00b7 <code>TypeScript</code> \u00b7 <code>pytest</code> \u00b7 <code>Vitest</code> \u00b7 <code>FastAPI</code> \u00b7 <code>React</code> \u00b7 <code>JUnit</code></p>"},{"location":"#tp-2-cicd-avec-github-actions","title":"TP 2 : CI/CD avec GitHub Actions","text":"<p>Objectif : Automatiser les tests et le d\u00e9ploiement avec GitHub Actions</p> <p>Ce que vous allez apprendre :</p> <ul> <li>\ud83d\udd04 Workflows GitHub Actions (backend, frontend, full-stack)</li> <li>\ud83d\ude80 CI Pipeline : Tests automatiques \u00e0 chaque commit</li> <li>\ud83d\udd12 Protection de branche : Bloquer les merges si tests \u00e9chouent</li> <li>\u26a1 Optimisation : Cache, jobs parall\u00e8les, tests rapides/lents</li> <li>\ud83c\udfaf Reusable Workflows : Orchestrer plusieurs workflows</li> </ul> <p>Technologies : <code>GitHub Actions</code> \u00b7 <code>YAML</code> \u00b7 <code>CI/CD</code> \u00b7 <code>Workflows</code></p>"},{"location":"#tp-3-deploiement-en-production","title":"TP 3 : D\u00e9ploiement en Production","text":"<p>Objectif : D\u00e9ployer l'application sur Render avec PostgreSQL</p> <p>Ce que vous allez apprendre :</p> <ul> <li>\ud83d\udc18 PostgreSQL : Migrer de la m\u00e9moire \u00e0 une vraie base de donn\u00e9es</li> <li>\ud83d\ude80 Render : D\u00e9ployer backend + frontend + base de donn\u00e9es</li> <li>\ud83d\udd10 Variables d'environnement et secrets</li> <li>\ud83d\udcca Monitoring : Logs, m\u00e9triques, sant\u00e9 de l'application</li> <li>\u267b\ufe0f CD : D\u00e9ploiement automatique apr\u00e8s chaque merge</li> </ul> <p>Technologies : <code>PostgreSQL</code> \u00b7 <code>Render</code> \u00b7 <code>Environment Variables</code> \u00b7 <code>CD</code></p>"},{"location":"#commencer","title":"\ud83d\ude80 Commencer","text":""},{"location":"#prerequis","title":"Pr\u00e9requis","text":"<ul> <li>\u2705 Git install\u00e9</li> <li>\u2705 Python 3.11+ ou UV</li> <li>\u2705 Node.js 18+</li> <li>\u2705 Compte GitHub</li> <li>\u2705 Java 17+ pour les exercices bonus</li> </ul>"},{"location":"#installation","title":"Installation","text":"<ol> <li> <p>Forker le repository : github.com/umons-ig/edl-starter</p> </li> <li> <p>Cloner votre fork :</p> </li> </ol> <pre><code>git clone https://github.com/VOTRE_NOM/edl-starter\ncd edl-starter\n</code></pre> <ol> <li>Suivre le TP 1 pour installer les d\u00e9pendances</li> </ol>"},{"location":"#navigation","title":"\ud83d\udcd6 Navigation","text":"<p>Utilisez le menu de gauche pour naviguer entre les diff\u00e9rents travaux pratiques.</p> <p>Chaque TP est ind\u00e9pendant mais suit une progression logique :</p> <pre><code>TP 1 (Tests) \u2192 TP 2 (CI/CD) \u2192 TP 3 (D\u00e9ploiement)\n</code></pre>"},{"location":"#stack-technique","title":"\ud83d\udee0\ufe0f Stack Technique","text":"<p>Backend :</p> <ul> <li>FastAPI (Python)</li> <li>pytest pour les tests</li> <li>UV pour la gestion des d\u00e9pendances</li> <li>PostgreSQL en production</li> </ul> <p>Frontend :</p> <ul> <li>React + TypeScript</li> <li>Vite pour le build</li> <li>Vitest pour les tests</li> <li>TailwindCSS pour le style</li> </ul> <p>DevOps :</p> <ul> <li>GitHub Actions pour CI/CD</li> <li>Render pour le d\u00e9ploiement</li> <li>MkDocs pour la documentation</li> </ul> <p>Pr\u00eat \u00e0 commencer ? \ud83d\udc49 TP 1 : Tests Unitaires</p>"},{"location":"TP-1/","title":"\ud83c\udf93 TP 1 : Tests Unitaires Backend &amp; Frontend","text":"<p>Objectif : Apprendre les tests unitaires avec Python (pytest) et TypeScript (Vitest)</p>"},{"location":"TP-1/#phase-1-installation-configuration","title":"Phase 1 : Installation &amp; Configuration","text":""},{"location":"TP-1/#etape-11-forker-le-depot","title":"\u00c9tape 1.1 : Forker le D\u00e9p\u00f4t","text":"<ol> <li>Allez sur <code>https://github.com/umons-ig/edl-starter</code></li> <li>Cliquez sur \"Fork\"</li> </ol> <ol> <li>Clonez votre fork :</li> </ol> <pre><code>git clone https://github.com/VOTRE_NOM/edl-starter\ncd edl-starter\n</code></pre>"},{"location":"TP-1/#etape-12-installer-les-dependances-python-2-options","title":"\u00c9tape 1.2 : Installer les D\u00e9pendances Python (2 Options)","text":"<p>Option A : Avec UV (Recommand\u00e9 - Plus Rapide) \u26a1</p> <p>UV est un gestionnaire de paquets Python moderne et ultra-rapide.</p> <p>Installation UV :</p> <p>macOS/Linux :</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Windows :</p> <pre><code>powershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>Installer les d\u00e9pendances :</p> <pre><code>cd backend\nuv venv\nsource .venv/bin/activate  # Windows: .venv\\Scripts\\activate\nuv sync\n</code></pre> <p>Option B : Avec pip (Classique) \ud83d\udc0d</p> <p>Si vous pr\u00e9f\u00e9rez pip ou avez d\u00e9j\u00e0 Python install\u00e9 :</p> <pre><code>cd backend\npython -m venv .venv\nsource .venv/bin/activate  # Windows: .venv\\Scripts\\activate\npip install -r requirements.txt\n</code></pre> <p>Dans le reste de l'atelier :</p> <ul> <li>Si vous utilisez UV : <code>uv run pytest</code></li> <li>Si vous utilisez pip : <code>pytest</code></li> </ul>"},{"location":"TP-1/#phase-2-explorer-lapplication","title":"Phase 2 : Explorer l'Application","text":""},{"location":"TP-1/#etape-21-lancer-le-serveur","title":"\u00c9tape 2.1 : Lancer le Serveur","text":"<pre><code>uv run uvicorn src.app:app --reload\n</code></pre>"},{"location":"TP-1/#etape-22-tester-dans-le-navigateur","title":"\u00c9tape 2.2 : Tester dans le Navigateur","text":"<p>Visitez :</p> <ul> <li>API : http://localhost:8000</li> <li>Documentation interactive : http://localhost:8000/docs</li> <li>Sant\u00e9 : http://localhost:8000/health</li> </ul>"},{"location":"TP-1/#etape-23-tester-avec-swagger-ui","title":"\u00c9tape 2.3 : Tester avec Swagger UI","text":"<ol> <li>Allez sur http://localhost:8000/docs</li> <li>Cliquez sur POST /tasks</li> <li>Cliquez sur \"Try it out\"</li> <li>Entrez :</li> </ol> <pre><code>{\n  \"title\": \"Ma premi\u00e8re t\u00e2che\",\n  \"description\": \"Apprendre FastAPI\"\n}\n</code></pre> <ol> <li>Cliquez sur \"Execute\"</li> <li>Vous devriez voir un code <code>201 Created</code></li> </ol>"},{"location":"TP-1/#etape-24-explorer-le-code","title":"\u00c9tape 2.4 : Explorer le Code","text":"<p>Ouvrez <code>backend/src/app.py</code> dans votre \u00e9diteur :</p> <ul> <li>Lignes 27-36 : \u00c9num\u00e9rations (TaskStatus, TaskPriority)</li> <li>Lignes 39-68 : Mod\u00e8les Pydantic</li> <li>Lignes 76-77 : Stockage en m\u00e9moire (dictionnaire simple)</li> <li>Lignes 180-205 : Endpoint pour cr\u00e9er une t\u00e2che</li> <li>Lignes 144-160 : Endpoint pour lister les t\u00e2ches</li> </ul> <p>Important : Ce backend utilise un stockage en m\u00e9moire (un simple dictionnaire Python) pour les TP 1 &amp; 2. Vous utiliserez PostgreSQL dans le TP 3.</p>"},{"location":"TP-1/#phase-3-comprendre-les-tests","title":"Phase 3 : Comprendre les Tests","text":""},{"location":"TP-1/#etape-31-explorer-les-fichiers-de-test","title":"\u00c9tape 3.1 : Explorer les Fichiers de Test","text":"<p>Ouvrez ces fichiers :</p> <ul> <li><code>backend/tests/conftest.py</code> \u2192 Fixtures de test</li> <li><code>backend/tests/test_api.py</code> \u2192 Tests</li> </ul>"},{"location":"TP-1/#etape-32-quest-ce-quune-fixture","title":"\u00c9tape 3.2 : Qu'est-ce qu'une Fixture ?","text":"<p>Dans <code>conftest.py</code>, regardez :</p> <pre><code>@pytest.fixture(autouse=True)\ndef clean_tasks():\n    \"\"\"Nettoie les t\u00e2ches avant et apr\u00e8s chaque test\"\"\"\n    clear_tasks()\n    yield\n    clear_tasks()\n\n@pytest.fixture\ndef client():\n    \"\"\"Fournit un client HTTP de test\"\"\"\n    with TestClient(app) as test_client:\n        yield test_client\n</code></pre> <p>Pourquoi c'est utile ?</p> <ul> <li><code>clean_tasks</code> : Nettoie automatiquement le stockage en m\u00e9moire avant chaque test</li> <li><code>client</code> : Vous n'avez pas \u00e0 cr\u00e9er un client dans chaque test</li> <li>pytest les injecte automatiquement quand vous \u00e9crivez <code>def test_xxx(client):</code></li> </ul>"},{"location":"TP-1/#etape-33-lancer-les-tests-existants","title":"\u00c9tape 3.3 : Lancer les Tests Existants","text":"<pre><code>uv run pytest -v\n</code></pre> <p>Vous devriez voir :</p> <pre><code>tests/test_api.py::test_root_endpoint PASSED\ntests/test_api.py::test_health_check PASSED\ntests/test_api.py::test_create_task PASSED\ntests/test_api.py::test_list_tasks PASSED\ntests/test_api.py::test_get_task_by_id PASSED\n... (19 tests au total)\n\n========== 19 passed in 0.45s ==========\n</code></pre>"},{"location":"TP-1/#etape-34-comprendre-un-test","title":"\u00c9tape 3.4 : Comprendre un Test","text":"<p>Regardez <code>test_create_task</code> dans <code>test_api.py</code> :</p> <pre><code>def test_create_task(client):\n    # ARRANGE : Pr\u00e9parer les donn\u00e9es\n    new_task = {\n        \"title\": \"Acheter des courses\",\n        \"description\": \"Lait, \u0153ufs, pain\"\n    }\n\n    # ACT : Faire la requ\u00eate\n    response = client.post(\"/tasks\", json=new_task)\n\n    # ASSERT : V\u00e9rifier\n    assert response.status_code == 201\n    assert response.json()[\"title\"] == \"Acheter des courses\"\n</code></pre> <p>Pattern Arrange-Act-Assert :</p> <ol> <li>Arrange \u2192 Pr\u00e9parer</li> <li>Act \u2192 Agir</li> <li>Assert \u2192 V\u00e9rifier</li> </ol>"},{"location":"TP-1/#phase-4-implementer-les-fonctions-backend","title":"Phase 4 : Impl\u00e9menter les Fonctions Backend","text":""},{"location":"TP-1/#exercice-1-implementer-delete_task","title":"\u270d\ufe0f Exercice 1 : Impl\u00e9menter <code>delete_task()</code>","text":"<p>\ud83c\udfaf Objectif : Compl\u00e9ter la fonction <code>delete_task()</code> dans <code>backend/src/app.py</code></p> <p>Ouvrez <code>backend/src/app.py</code> et trouvez la fonction <code>delete_task()</code> (ligne ~240).</p> <p>Les tests existent d\u00e9j\u00e0 ! Regardez dans <code>test_api.py</code> :</p> <ul> <li><code>test_delete_task</code> : Supprime une t\u00e2che et v\u00e9rifie qu'elle a disparu</li> <li><code>test_delete_nonexistent_task</code> : V\u00e9rifie le 404</li> </ul> <p>Votre mission :</p> <p>Impl\u00e9mentez les 3 \u00e9tapes d\u00e9crites dans le TODO :</p> <pre><code>@app.delete(\"/tasks/{task_id}\", status_code=204)\nasync def delete_task(task_id: int):\n    # TODO: Votre code ici\n    # 1. V\u00e9rifier que la t\u00e2che existe\n    # 2. La supprimer de tasks_db\n    # 3. Retourner None\n</code></pre> <p>V\u00e9rifier votre code :</p> <pre><code>cd backend\nuv run pytest tests/test_api.py::test_delete_task -v\n</code></pre> <p>\u2705 Si le test passe \u2192 Bravo !</p> <p>\u274c Si le test \u00e9choue \u2192 Lisez l'erreur et corrigez</p>"},{"location":"TP-1/#exercice-2-implementer-update_task","title":"\u270d\ufe0f Exercice 2 : Impl\u00e9menter <code>update_task()</code>","text":"<p>\ud83c\udfaf Objectif : Compl\u00e9ter la fonction <code>update_task()</code> dans <code>backend/src/app.py</code></p> <p>Trouvez la fonction <code>update_task()</code> (ligne ~207).</p> <p>Les tests existent d\u00e9j\u00e0 ! Regardez :</p> <ul> <li><code>test_update_task</code> : Change le titre d'une t\u00e2che</li> <li><code>test_update_task_status</code> : Change le statut</li> <li><code>test_update_nonexistent_task</code> : V\u00e9rifie le 404</li> </ul> <p>Votre mission :</p> <p>Impl\u00e9mentez les 7 \u00e9tapes d\u00e9crites dans le TODO.</p> <p>Indices :</p> <ol> <li>C'est similaire \u00e0 <code>create_task</code> mais avec une t\u00e2che existante</li> <li>Utilisez <code>updates.model_dump(exclude_unset=True)</code> pour obtenir les champs fournis</li> <li>Utilisez <code>update_data.get(\"field\", existing_task.field)</code> pour garder les anciennes valeurs si non mises \u00e0 jour</li> </ol> <p>V\u00e9rifier votre code :</p> <pre><code>uv run pytest tests/test_api.py::test_update_task -v\n</code></pre>"},{"location":"TP-1/#exercice-3-ecrire-un-test-de-suppression-inexistante","title":"\u270d\ufe0f Exercice 3 : \u00c9crire un Test de Suppression Inexistante","text":"<p>\ud83c\udfaf Objectif : Tester qu'on ne peut pas supprimer une t\u00e2che qui n'existe pas</p> <p>Ouvrez <code>backend/tests/test_api.py</code> et trouvez la section DELETE TASK TESTS.</p> <p>Ajoutez ce test apr\u00e8s <code>test_delete_task</code> :</p> <pre><code>def test_delete_nonexistent_task_returns_404(client):\n    \"\"\"Deleting a task that doesn't exist should return 404.\"\"\"\n    # TODO: Votre code ici\n    # 1. Essayer de supprimer une t\u00e2che avec un ID qui n'existe pas (ex: 9999)\n    # 2. V\u00e9rifier que \u00e7a retourne 404\n    # 3. V\u00e9rifier le message d'erreur contient \"not found\"\n</code></pre> <p>V\u00e9rifier :</p> <pre><code>uv run pytest tests/test_api.py::test_delete_nonexistent_task_returns_404 -v\n</code></pre>"},{"location":"TP-1/#exercice-4-ecrire-un-test-de-validation","title":"\u270d\ufe0f Exercice 4 : \u00c9crire un Test de Validation","text":"<p>\ud83c\udfaf Objectif : Tester qu'on ne peut pas mettre \u00e0 jour une t\u00e2che avec une priorit\u00e9 invalide</p> <p>Ouvrez <code>backend/tests/test_api.py</code> et trouvez la fonction <code>test_update_task_with_invalid_priority</code>.</p> <pre><code>def test_update_task_with_invalid_priority(client):\n    \"\"\"Updating a task with an invalid priority should fail.\"\"\"\n    # TODO: Votre code ici\n    # 1. Cr\u00e9er une t\u00e2che valide\n    # 2. Essayer de la mettre \u00e0 jour avec priority=\"urgent\" (invalide)\n    # 3. V\u00e9rifier que \u00e7a retourne 422 (Erreur de Validation)\n</code></pre> <p>Rappel : Les priorit\u00e9s valides sont <code>\"low\"</code>, <code>\"medium\"</code>, <code>\"high\"</code> (voir <code>TaskPriority</code> dans <code>app.py</code>)</p> <p>V\u00e9rifier :</p> <pre><code>uv run pytest tests/test_api.py::test_update_task_with_invalid_priority -v\n</code></pre>"},{"location":"TP-1/#exercice-5-ecrire-un-test-de-filtrage","title":"\u270d\ufe0f Exercice 5 : \u00c9crire un Test de Filtrage","text":"<p>\ud83c\udfaf Objectif : Tester le filtrage avec plusieurs crit\u00e8res</p> <p>Ajoutez ce test dans la section FILTER TASKS TESTS :</p> <pre><code>def test_filter_by_multiple_criteria(client):\n    \"\"\"Filtering by status AND priority should work.\"\"\"\n    # TODO: Votre code ici\n    # 1. Cr\u00e9er 3 t\u00e2ches avec diff\u00e9rents status et priority\n    # 2. Filtrer avec GET /tasks?status=todo&amp;priority=high\n    # 3. V\u00e9rifier qu'on re\u00e7oit seulement les bonnes t\u00e2ches\n</code></pre> <p>V\u00e9rifier :</p> <pre><code>uv run pytest tests/test_api.py::test_filter_by_multiple_criteria -v\n</code></pre>"},{"location":"TP-1/#etape-46-lancer-tous-les-tests","title":"\u00c9tape 4.6 : Lancer TOUS les Tests","text":"<p>Une fois que vous avez termin\u00e9 les 5 exercices, lancez tous les tests :</p> <pre><code>uv run pytest -v\n</code></pre> <p>R\u00e9sultat attendu :</p> <pre><code>tests/test_api.py::test_root_endpoint PASSED\ntests/test_api.py::test_health_check PASSED\ntests/test_api.py::test_create_simple_task PASSED\n...\ntests/test_api.py::test_delete_task PASSED\ntests/test_api.py::test_update_task PASSED\ntests/test_api.py::test_delete_nonexistent_task_returns_404 PASSED\ntests/test_api.py::test_update_task_with_empty_title PASSED\ntests/test_api.py::test_filter_by_multiple_criteria PASSED\n...\n========== 22+ passed in 0.5s ==========\n</code></pre> <p>\ud83c\udf89 Tous les tests passent ? Vous avez r\u00e9ussi !</p>"},{"location":"TP-1/#phase-5-couverture-de-code","title":"Phase 5 : Couverture de Code","text":""},{"location":"TP-1/#etape-51-lancer-les-tests-avec-couverture","title":"\u00c9tape 5.1 : Lancer les Tests avec Couverture","text":"<pre><code>uv run pytest --cov\n</code></pre> <p>R\u00e9sultat :</p> <pre><code>---------- coverage: platform darwin, python 3.12.7 -----------\nName                Stmts   Miss  Cover\n---------------------------------------\nsrc/app.py            156      6    96%\n---------------------------------------\nTOTAL                 156      6    96%\n</code></pre> <p></p>"},{"location":"TP-1/#etape-52-generer-un-rapport-html","title":"\u00c9tape 5.2 : G\u00e9n\u00e9rer un Rapport HTML","text":"<pre><code>uv run pytest --cov --cov-report=html\n</code></pre> <p>Ouvrir le rapport :</p> <pre><code>open htmlcov/index.html  # macOS\nstart htmlcov/index.html  # Windows\n</code></pre>"},{"location":"TP-1/#phase-6-tests-frontend","title":"Phase 6 : Tests Frontend","text":""},{"location":"TP-1/#etape-61-comprendre-le-frontend-et-pourquoi-tester","title":"\u00c9tape 6.1 : Comprendre le Frontend et Pourquoi Tester","text":"<p>Le frontend est une application React + TypeScript simple qui communique avec le backend.</p> <p>Structure :</p> <pre><code>frontend/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 App.tsx              # Composant principal\n\u2502   \u251c\u2500\u2500 App.css              # Styles simples\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u251c\u2500\u2500 api.ts           # Client API\n\u2502   \u2502   \u2514\u2500\u2500 api.test.ts      # Tests API \u2190 ON TESTE \u00c7A\n\u2502   \u2514\u2500\u2500 components/\n\u2502       \u251c\u2500\u2500 SimpleTaskList.tsx\n\u2502       \u2514\u2500\u2500 TaskForm.tsx\n\u2514\u2500\u2500 package.json\n</code></pre>"},{"location":"TP-1/#pourquoi-tester-le-frontend","title":"\ud83e\udd14 Pourquoi Tester le Frontend ?","text":"<p>1. V\u00e9rifier la Communication avec le Backend</p> <p>Les tests frontend v\u00e9rifient que votre code JavaScript/TypeScript communique correctement avec l'API backend :</p> <ul> <li>\u2705 Les requ\u00eates HTTP sont-elles correctement form\u00e9es ? (bonne URL, bonne m\u00e9thode, bon format)</li> <li>\u2705 Les donn\u00e9es sont-elles correctement envoy\u00e9es ? (body JSON valide)</li> <li>\u2705 Les r\u00e9ponses sont-elles correctement trait\u00e9es ? (parsing JSON, extraction des donn\u00e9es)</li> <li>\u2705 Les erreurs sont-elles g\u00e9r\u00e9es ? (404, 500, network errors)</li> </ul> <p>2. Tester Sans D\u00e9pendre du Backend</p> <p>Gr\u00e2ce au mocking, on peut tester le frontend m\u00eame si :</p> <ul> <li>\u274c Le backend n'est pas encore d\u00e9velopp\u00e9</li> <li>\u274c Le backend est en panne</li> <li>\u274c On n'a pas de connexion Internet</li> <li>\u274c On veut tester des cas d'erreur difficiles \u00e0 reproduire</li> </ul> <p>Exemple : Comment tester une erreur 500 sans crasher votre vrai backend ? \u2192 Avec un mock !</p> <p>3. Tests Rapides et Fiables</p> <ul> <li>\u26a1 Rapides : Pas besoin de lancer un vrai serveur</li> <li>\ud83d\udd12 Isol\u00e9s : Pas d'effets de bord entre les tests</li> <li>\ud83c\udfaf Pr\u00e9cis : On teste uniquement la logique frontend</li> </ul>"},{"location":"TP-1/#quest-ce-quon-teste","title":"\ud83d\udce6 Qu'est-ce qu'on Teste ?","text":"<p>Dans cet atelier, on teste uniquement le module API (<code>api.ts</code>), pas les composants React.</p> <p>Pourquoi ne pas tester les composants React ?</p> <ul> <li>Les tests de composants React n\u00e9cessitent des outils suppl\u00e9mentaires (React Testing Library)</li> <li>C'est plus complexe (gestion du DOM, \u00e9v\u00e9nements, \u00e9tat)</li> <li>Pour le TP 1, on se concentre sur les concepts de base des tests</li> </ul> <p>Ce qu'on teste dans <code>api.ts</code> :</p> Fonction Ce qu'elle fait Ce qu'on v\u00e9rifie <code>getTasks()</code> R\u00e9cup\u00e8re la liste des t\u00e2ches Retourne un tableau de t\u00e2ches <code>createTask()</code> Cr\u00e9e une nouvelle t\u00e2che Envoie les bonnes donn\u00e9es en POST <code>deleteTask()</code> Supprime une t\u00e2che Appelle DELETE avec le bon ID <code>updateTask()</code> Met \u00e0 jour une t\u00e2che Envoie PUT avec les modifications"},{"location":"TP-1/#le-concept-de-mocking","title":"\ud83c\udfad Le Concept de Mocking","text":"<p>Probl\u00e8me : Comment tester du code qui appelle une API externe ?</p> <p>Solution : On simule (mock) la fonction <code>fetch()</code> pour qu'elle retourne ce qu'on veut !</p> <pre><code>// Au lieu d'appeler le vrai backend...\nfetch('http://localhost:8000/tasks')\n\n// ...on remplace fetch par une fausse version qui retourne ce qu'on veut\n(globalThis as any).fetch = vi.fn(() =&gt;\n  Promise.resolve({\n    ok: true,\n    json: () =&gt; Promise.resolve([{ id: 1, title: 'Test' }])\n  })\n);\n</code></pre> <p>Avantages :</p> <ul> <li>\u2705 Pas besoin du vrai backend</li> <li>\u2705 Contr\u00f4le total sur les r\u00e9ponses (succ\u00e8s, erreurs, cas limites)</li> <li>\u2705 Tests ultra-rapides</li> </ul>"},{"location":"TP-1/#decorticage-ligne-par-ligne-du-mock","title":"\ud83d\udd2c D\u00e9corticage Ligne par Ligne du Mock","text":"<p>Analysons en d\u00e9tail ce code de mocking qui peut sembler complexe au premier abord :</p> <pre><code>(globalThis as any).fetch = vi.fn(() =&gt;\n  Promise.resolve({\n    ok: true,\n    json: () =&gt; Promise.resolve([\n      { id: 1, title: 'Test Task', status: 'todo' }\n    ]),\n  })\n);\n</code></pre> <p>Ligne 1 : Remplacer la vraie fonction <code>fetch()</code></p> <pre><code>(globalThis as any).fetch = vi.fn(...)\n</code></pre> \u00c9l\u00e9ment Explication <code>globalThis</code> Objet JavaScript global (\u00e9quivalent de <code>window</code> dans le navigateur) <code>.fetch</code> La vraie fonction qui fait les requ\u00eates HTTP <code>vi.fn(...)</code> Cr\u00e9e une fonction \"espion\" (mock) de Vitest <code>(globalThis as any)</code> TypeScript : on force le type pour pouvoir modifier fetch <p>Ce qu'on fait : On remplace la vraie <code>fetch()</code> par une fausse version qu'on contr\u00f4le !</p> <p>Ligne 2 : Simuler une Promesse r\u00e9ussie</p> <pre><code>Promise.resolve({...})\n</code></pre> <ul> <li><code>fetch()</code> retourne toujours une Promise (asynchrone)</li> <li><code>Promise.resolve()</code> simule une promesse qui r\u00e9ussit imm\u00e9diatement</li> <li>On pourrait utiliser <code>Promise.reject()</code> pour simuler une erreur r\u00e9seau</li> </ul> <p>Ligne 3-7 : Simuler la r\u00e9ponse HTTP</p> <pre><code>{\n  ok: true,                    // \u2705 Statut de la r\u00e9ponse\n  json: () =&gt; Promise.resolve([...])  // \ud83d\udce6 Les donn\u00e9es JSON\n}\n</code></pre> Propri\u00e9t\u00e9 Valeur Signification <code>ok</code> <code>true</code> La requ\u00eate HTTP a r\u00e9ussi (status 200-299) <code>ok</code> <code>false</code> La requ\u00eate a \u00e9chou\u00e9 (status 400-599) <code>json()</code> Une fonction qui retourne une Promise Simule <code>response.json()</code> <p>Pourquoi <code>json()</code> est une fonction ?</p> <p>Le vrai <code>fetch()</code> fonctionne comme \u00e7a :</p> <pre><code>const response = await fetch('/tasks');  // \u00c9tape 1 : Obtenir la r\u00e9ponse\nconst data = await response.json();      // \u00c9tape 2 : Parser le JSON\n</code></pre> <p>Notre mock doit imiter exactement ce comportement !</p> <p>Ligne 4-6 : Les donn\u00e9es retourn\u00e9es</p> <pre><code>[\n  { id: 1, title: 'Test Task', status: 'todo' }\n]\n</code></pre> <p>C'est le tableau de t\u00e2ches fictif que notre mock va retourner. On peut mettre ce qu'on veut !</p>"},{"location":"TP-1/#exemples-de-mocks-pour-differents-cas","title":"\ud83c\udfa8 Exemples de Mocks pour Diff\u00e9rents Cas","text":"<p>1\ufe0f\u20e3 Mock pour un Succ\u00e8s (200 OK)</p> <pre><code>(globalThis as any).fetch = vi.fn(() =&gt;\n  Promise.resolve({\n    ok: true,\n    status: 200,\n    json: () =&gt; Promise.resolve({ id: 1, title: 'Ma t\u00e2che' })\n  })\n);\n</code></pre> <p>2\ufe0f\u20e3 Mock pour une Erreur 404 (Not Found)</p> <pre><code>(globalThis as any).fetch = vi.fn(() =&gt;\n  Promise.resolve({\n    ok: false,\n    status: 404,\n    statusText: 'Not Found'\n  })\n);\n</code></pre> <p>3\ufe0f\u20e3 Mock pour une Erreur 500 (Server Error)</p> <pre><code>(globalThis as any).fetch = vi.fn(() =&gt;\n  Promise.resolve({\n    ok: false,\n    status: 500,\n    statusText: 'Server Error'\n  })\n);\n</code></pre> <p>4\ufe0f\u20e3 Mock pour une Erreur R\u00e9seau (pas de connexion)</p> <pre><code>(globalThis as any).fetch = vi.fn(() =&gt;\n  Promise.reject(new Error('Network error'))\n);\n</code></pre>"},{"location":"TP-1/#questions-frequentes-sur-le-mocking","title":"\u2753 Questions Fr\u00e9quentes sur le Mocking","text":"<p>Q : Pourquoi <code>(globalThis as any)</code> ?</p> <p>R : TypeScript prot\u00e8ge <code>globalThis.fetch</code> contre les modifications. <code>as any</code> dit \u00e0 TypeScript \"Fais-moi confiance, je sais ce que je fais !\" C'est normal dans les tests.</p> <p>Q : Pourquoi <code>vi.fn()</code> au lieu d'une fonction normale ?</p> <p>R : <code>vi.fn()</code> cr\u00e9e un spy (espion). On peut ensuite v\u00e9rifier :</p> <pre><code>expect(mockFetch).toHaveBeenCalledWith('/tasks/1', { method: 'DELETE' });\n</code></pre> <p>Avec une fonction normale, on ne pourrait pas faire \u00e7a !</p> <p>Q : Dois-je mocker <code>fetch()</code> dans chaque test ?</p> <p>R : OUI ! Chaque test est isol\u00e9. Si vous ne mocker pas <code>fetch()</code>, le test essaiera d'appeler le vrai backend et \u00e9chouera.</p> <p>Q : Le mock persiste-t-il entre les tests ?</p> <p>R : Non, Vitest r\u00e9initialise les mocks automatiquement entre chaque test. C'est pour garantir l'isolation des tests.</p>"},{"location":"TP-1/#recapitulatif","title":"\ud83c\udfaf R\u00e9capitulatif","text":"Concept Signification Mock Fausse version d'une fonction qu'on contr\u00f4le <code>globalThis.fetch</code> La vraie fonction HTTP qu'on remplace <code>vi.fn()</code> Cr\u00e9e un mock espion (peut \u00eatre v\u00e9rifi\u00e9) <code>Promise.resolve()</code> Simule une promesse qui r\u00e9ussit <code>ok: true</code> Simule un succ\u00e8s HTTP (200-299) <code>json()</code> Fonction qui retourne les donn\u00e9es JSON <p>Important : On teste uniquement l'API (pas les composants React) pour rester simple.</p>"},{"location":"TP-1/#etape-62-installer-les-dependances-frontend","title":"\u00c9tape 6.2 : Installer les D\u00e9pendances Frontend","text":"<pre><code>cd frontend\nnpm install\n</code></pre> <p>Cela va installer toutes les d\u00e9pendances d\u00e9finies dans <code>package.json</code>.</p>"},{"location":"TP-1/#etape-63-lancer-les-tests-frontend","title":"\u00c9tape 6.3 : Lancer les Tests Frontend","text":"<pre><code>npm test\n</code></pre> <p>Vous devriez voir :</p> <pre><code>\u2713 src/api/api.test.ts (3 tests) 4ms\n  \u2713 fetches tasks from the backend\n  \u2713 creates a new task\n  \u2713 throws error when API fails\n\nTest Files  1 passed (1)\n     Tests  3 passed (3)\n</code></pre>"},{"location":"TP-1/#etape-64-analyser-les-tests-en-detail","title":"\u00c9tape 6.4 : Analyser les Tests en D\u00e9tail","text":"<p>Ouvrez <code>frontend/src/api/api.test.ts</code> et analysons ligne par ligne comment fonctionne un test :</p> <pre><code>describe('API Module', () =&gt; {\n  it('fetches tasks from the backend', async () =&gt; {\n    // \u00c9TAPE 1 : Mock fetch pour simuler la r\u00e9ponse du backend\n    (globalThis as any).fetch = vi.fn(() =&gt;\n      Promise.resolve({\n        ok: true,\n        json: () =&gt; Promise.resolve([\n          { id: 1, title: 'Test Task', status: 'todo' }\n        ]),\n      })\n    );\n\n    // \u00c9TAPE 2 : Appeler la fonction \u00e0 tester\n    const tasks = await api.getTasks();\n\n    // \u00c9TAPE 3 : V\u00e9rifier les r\u00e9sultats\n    expect(tasks).toHaveLength(1);\n    expect(tasks[0].title).toBe('Test Task');\n  });\n});\n</code></pre>"},{"location":"TP-1/#explication-detaillee","title":"\ud83d\udd0d Explication D\u00e9taill\u00e9e","text":"<p>\u00c9TAPE 1 : Pourquoi mocker <code>fetch()</code> ?</p> <pre><code>(globalThis as any).fetch = vi.fn(() =&gt; ...)\n</code></pre> <ul> <li><code>globalThis.fetch</code> = la fonction JavaScript qui fait les requ\u00eates HTTP</li> <li><code>vi.fn()</code> = remplace fetch par une fausse version (mock) de Vitest</li> <li>On contr\u00f4le ce qu'elle retourne \u2192 pas d'appel r\u00e9seau r\u00e9el</li> </ul> <p>Ce que le mock retourne :</p> <pre><code>Promise.resolve({\n  ok: true,                    // \u2705 Requ\u00eate r\u00e9ussie (pas d'erreur)\n  json: () =&gt; Promise.resolve([...])  // Les donn\u00e9es JSON \u00e0 retourner\n})\n</code></pre> <p>C'est exactement ce que le vrai <code>fetch()</code> retournerait, mais sans r\u00e9seau !</p> <p>\u00c9TAPE 2 : Appeler la fonction</p> <pre><code>const tasks = await api.getTasks();\n</code></pre> <ul> <li>Appelle la vraie fonction <code>getTasks()</code> de notre API</li> <li>Cette fonction utilise <code>fetch()</code> en interne</li> <li>Mais <code>fetch()</code> est maintenant notre mock \u2192 retourne instantan\u00e9ment les donn\u00e9es fictives</li> </ul> <p>\u00c9TAPE 3 : V\u00e9rifier les r\u00e9sultats</p> <pre><code>expect(tasks).toHaveLength(1);       // \u2705 On a bien re\u00e7u 1 t\u00e2che\nexpect(tasks[0].title).toBe('Test Task');  // \u2705 Le titre est correct\n</code></pre>"},{"location":"TP-1/#comparaison-backend-vs-frontend","title":"\ud83d\udcca Comparaison Backend vs Frontend","text":"Aspect Tests Backend (pytest) Tests Frontend (Vitest) Framework pytest Vitest Langage Python TypeScript Assertions <code>assert response.status_code == 200</code> <code>expect(response.ok).toBe(true)</code> Mocking Fixtures (<code>client</code>) <code>vi.fn()</code> Asynchrone Pas n\u00e9cessaire (FastAPI le g\u00e8re) <code>async/await</code> obligatoire Pattern Arrange-Act-Assert Arrange-Act-Assert (identique!) <p>La bonne nouvelle : Les concepts sont identiques entre backend et frontend !</p>"},{"location":"TP-1/#les-5-tests-expliques","title":"\ud83c\udfaf Les 5 Tests Expliqu\u00e9s","text":"Test Objectif Ce qu'on v\u00e9rifie Test 1 : <code>fetches tasks</code> R\u00e9cup\u00e9rer des t\u00e2ches \u2705 Re\u00e7oit un tableau avec les bonnes donn\u00e9es Test 2 : <code>creates a new task</code> Cr\u00e9er une t\u00e2che \u2705 Envoie POST avec les bonnes donn\u00e9es Test 3 : <code>throws error when API fails</code> Gestion d'erreur \u2705 L\u00e8ve une exception si le backend r\u00e9pond 500 Test 4 : <code>deletes a task</code> Supprimer une t\u00e2che \u2705 Appelle DELETE avec le bon ID Test 5 : <code>updates a task</code> Mettre \u00e0 jour une t\u00e2che \u2705 Envoie PUT avec les modifications <p>Pourquoi ces tests sont importants ?</p> <ul> <li>\ud83d\udc1b D\u00e9tecter les bugs : Si on change l'URL de l'API, les tests \u00e9chouent</li> <li>\ud83d\udd12 Garantir la qualit\u00e9 : Les nouvelles fonctionnalit\u00e9s ne cassent pas l'existant</li> <li>\ud83d\udcd6 Documentation vivante : Les tests montrent comment utiliser l'API</li> </ul>"},{"location":"TP-1/#etape-65-couverture-frontend","title":"\u00c9tape 6.5 : Couverture Frontend","text":"<pre><code>npm run test:coverage\n</code></pre> <p>R\u00e9sultat :</p> <pre><code>File       | % Stmts | % Branch | % Funcs | % Lines |\n-----------|---------|----------|---------|---------|\napi.ts     |   68.42 |    55.55 |      50 |   68.42 |\n</code></pre> <p>Note : On teste uniquement l'API (pas les composants React).</p>"},{"location":"TP-1/#etape-66-comprendre-un-test-existant","title":"\u00c9tape 6.6 : Comprendre un Test Existant","text":"<p>Avant d'\u00e9crire votre test, analysons comment fonctionne le test <code>creates a new task</code> :</p> <pre><code>it('creates a new task', async () =&gt; {\n  // 1. ARRANGE : Pr\u00e9parer les donn\u00e9es\n  const newTask = { title: 'New Task', status: 'todo' as const };\n\n  // 2. ARRANGE : Mocker fetch pour simuler la r\u00e9ponse du backend\n  (globalThis as any).fetch = vi.fn(() =&gt;\n    Promise.resolve({\n      ok: true,\n      json: () =&gt; Promise.resolve({ ...newTask, id: 1 }),\n    })\n  );\n\n  // 3. ACT : Appeler la fonction \u00e0 tester\n  const created = await api.createTask(newTask);\n\n  // 4. ASSERT : V\u00e9rifier les r\u00e9sultats\n  expect(created.id).toBe(1);\n  expect(created.title).toBe('New Task');\n});\n</code></pre> <p>Que fait ce test ?</p> <ol> <li>Arrange : Pr\u00e9pare les donn\u00e9es (newTask) et mock fetch</li> <li>Act : Appelle <code>api.createTask()</code></li> <li>Assert : V\u00e9rifie que la t\u00e2che cr\u00e9\u00e9e a bien un ID et le bon titre</li> </ol> <p>Pattern AAA - le m\u00eame qu'en Python ! \ud83c\udfaf</p>"},{"location":"TP-1/#exercice-6-ecrire-un-test-frontend-10-min","title":"\u270d\ufe0f Exercice 6 : \u00c9crire un Test Frontend (10 min)","text":"<p>\ud83c\udfaf Objectif : Tester la fonction <code>deleteTask()</code> du module API</p> <p>Ouvrez <code>frontend/src/api/api.test.ts</code> et trouvez le test marqu\u00e9 <code>it.todo(...)</code> :</p> <pre><code>it.todo('deletes a task', async () =&gt; {\n  // TODO: Votre code ici\n  // 1. Mocker fetch pour simuler une suppression r\u00e9ussie (status: 204)\n  // 2. Appeler await api.deleteTask(1)\n  // 3. V\u00e9rifier que fetch a \u00e9t\u00e9 appel\u00e9 avec la bonne URL et m\u00e9thode DELETE\n});\n</code></pre> <p>Votre mission : Impl\u00e9mentez ce test en suivant les 3 \u00e9tapes !</p> <p>Indice : Regardez le test <code>creates a new task</code> juste au-dessus pour vous inspirer.</p> <p>V\u00e9rifier votre test :</p> <pre><code>cd frontend\nnpm test\n</code></pre> <p>\u2705 Si le test passe \u2192 Bravo ! Vous devriez voir 4 tests passed au lieu de 3 !</p> <p>\u274c Si le test \u00e9choue \u2192 Lisez l'erreur et corrigez</p>"},{"location":"TP-1/#exercice-7-ecrire-un-test-update-frontend-10-min","title":"\u270d\ufe0f Exercice 7 : \u00c9crire un Test UPDATE Frontend (10 min)","text":"<p>\ud83c\udfaf Objectif : Tester la fonction <code>updateTask()</code> du module API</p> <p>Dans <code>frontend/src/api/api.test.ts</code>, trouvez le deuxi\u00e8me test marqu\u00e9 <code>it.todo(...)</code> :</p> <pre><code>it.todo('updates a task', async () =&gt; {\n  // TODO: Votre code ici\n  // 1. Mocker fetch pour simuler une mise \u00e0 jour r\u00e9ussie\n  // 2. Appeler await api.updateTask(1, { title: 'Updated Title' })\n  // 3. V\u00e9rifier que fetch a \u00e9t\u00e9 appel\u00e9 avec la bonne URL, m\u00e9thode PUT et body\n});\n</code></pre> <p>Votre mission : Impl\u00e9mentez ce test en suivant les 3 \u00e9tapes !</p> <p>Indices :</p> <ol> <li>C'est similaire au test DELETE, mais avec m\u00e9thode <code>PUT</code> au lieu de <code>DELETE</code></li> <li>Il faut aussi v\u00e9rifier le <code>body</code> contient les bonnes donn\u00e9es</li> <li>Le mock fetch doit retourner un objet avec <code>json()</code> (comme dans <code>creates a new task</code>)</li> </ol> <p>V\u00e9rifier votre test :</p> <pre><code>npm test\n</code></pre> <p>\u2705 Si le test passe \u2192 Bravo ! Vous devriez voir 5 tests passed !</p> <p>\u274c Si le test \u00e9choue \u2192 Lisez l'erreur et corrigez</p>"},{"location":"TP-1/#etape-67-verifier-la-couverture","title":"\u00c9tape 6.7 : V\u00e9rifier la Couverture","text":"<pre><code>npm run test:coverage\n</code></pre> <p>R\u00e9sultat :</p> <pre><code>File       | % Stmts | % Branch | % Funcs | % Lines |\n-----------|---------|----------|---------|---------|\napi.ts     |   84.21 |    66.67 |   71.43 |   84.21 |\n</code></pre> <p>La couverture a augment\u00e9 gr\u00e2ce \u00e0 vos tests ! \ud83c\udf89</p>"},{"location":"TP-1/#etape-68-lancer-lapplication-complete","title":"\u00c9tape 6.8 : Lancer l'Application Compl\u00e8te","text":"<p>Terminal 1 - Backend :</p> <pre><code>cd backend\nuv run uvicorn src.app:app --reload\n</code></pre> <p>Terminal 2 - Frontend :</p> <pre><code>cd frontend\nnpm install  # Si pas d\u00e9j\u00e0 fait\nnpm run dev\n</code></pre> <p>Ouvrir dans le navigateur : http://localhost:5173</p> <p>Vous devriez voir l'application TaskFlow fonctionner :</p> <p></p>"},{"location":"TP-1/#exercices-bonus-java-avec-junit","title":"\ud83c\udf81 Exercices Bonus : Java avec JUnit","text":"<p>Objectif : Voir que les principes de TDD s'appliquent \u00e0 tous les langages !</p> <p>Les exercices Java sont dans le dossier <code>java-exercises/</code>.</p>"},{"location":"TP-1/#prerequis-installer-java","title":"Pr\u00e9requis : Installer Java","text":"<pre><code># V\u00e9rifier si d\u00e9j\u00e0 install\u00e9\njava -version    # Devrait afficher Java 17+\n</code></pre> <p>Si pas install\u00e9 :</p> <ul> <li>macOS : <code>brew install openjdk@17</code></li> <li>Linux : <code>sudo apt install openjdk-17-jdk</code></li> <li>Windows : Installer depuis adoptium.net</li> </ul> <p>Commandes de base :</p> <p>Chaque exercice utilise un Makefile pour simplifier la compilation et l'ex\u00e9cution :</p> <pre><code>make test     # Compiler + Ex\u00e9cuter les tests + Nettoyer\nmake compile  # Compiler uniquement\nmake clean    # Supprimer les fichiers .class\n</code></pre>"},{"location":"TP-1/#exercice-1-calculs-geometriques-composition-de-fonctions","title":"\u270d\ufe0f Exercice 1 : Calculs G\u00e9om\u00e9triques (Composition de Fonctions)","text":"<p>\ud83c\udfaf Objectif : Impl\u00e9menter des op\u00e9rations math\u00e9matiques en composant des fonctions simples</p> <p>Ouvrez le dossier <code>edl-starter/java-exercises/calculs-geo/</code></p> <p>Fichiers du projet :</p> <ul> <li><code>Addition.java</code> : Classe d'exemple d\u00e9j\u00e0 impl\u00e9ment\u00e9e</li> <li><code>Produit.java</code> : \u00c0 compl\u00e9ter (multiplication)</li> <li><code>Surface.java</code> : \u00c0 compl\u00e9ter (surface rectangle)</li> <li><code>Perimetre.java</code> : \u00c0 compl\u00e9ter (p\u00e9rim\u00e8tre)</li> <li>Tests : <code>AdditionTest.java</code>, <code>ProduitTest.java</code>, <code>SurfaceTest.java</code>, <code>PerimetreTest.java</code></li> </ul> <p>Votre mission - Partie 1 : Impl\u00e9menter <code>Produit.mult()</code></p> <p>Ouvrez <code>Produit.java</code> et compl\u00e9tez la m\u00e9thode :</p> <pre><code>public class Produit {\n    public static int mult(int a, int b) {\n        // TODO: Retourner le produit de a et b\n        return 0;\n    }\n}\n</code></pre> <p>Test correspondant (<code>ProduitTest.java</code>) :</p> <pre><code>@Test\npublic void testMult() {\n    assertEquals(6, Produit.mult(2, 3));\n    assertEquals(0, Produit.mult(0, 5));\n    assertEquals(-6, Produit.mult(-2, 3));\n}\n</code></pre> <p>Indice : Utilisez l'op\u00e9rateur <code>*</code> pour multiplier deux nombres.</p> <p>V\u00e9rifier votre code :</p> <pre><code>cd edl-starter/java-exercises/calculs-geo\nmake test\n</code></pre> <p>R\u00e9sultat attendu apr\u00e8s impl\u00e9mentation :</p> <pre><code>JUnit version 4.13.2\n..E.E\nTime: 0.006\nThere were 2 failures:\n...\nTests run: 4,  Failures: 2\n</code></pre> <p>Le test <code>ProduitTest</code> devrait maintenant passer !</p> <p>Votre mission - Partie 2 : Impl\u00e9menter <code>Surface.surf()</code></p> <p>Ouvrez <code>Surface.java</code> et compl\u00e9tez la m\u00e9thode :</p> <pre><code>public class Surface {\n    public static int surf(int a, int b) {\n        // TODO: Utiliser Produit.mult() pour calculer la surface d'un rectangle\n        return 0;\n    }\n}\n</code></pre> <p>Test correspondant (<code>SurfaceTest.java</code>) :</p> <pre><code>@Test\npublic void testSurf() {\n    assertEquals(6, Surface.surf(2, 3));\n    assertEquals(0, Surface.surf(0, 5));\n    assertEquals(12, Surface.surf(3, 4));\n}\n</code></pre> <p>Indice : La surface d'un rectangle = longueur \u00d7 largeur. R\u00e9utilisez la fonction <code>Produit.mult()</code> que vous venez d'\u00e9crire.</p> <p>Exemple de solution :</p> <pre><code>return Produit.mult(a, b);\n</code></pre> <p>V\u00e9rifier :</p> <pre><code>make test\n</code></pre> <p>Maintenant 2 tests sur 4 devraient passer.</p> <p>Votre mission - Partie 3 : Impl\u00e9menter <code>Perimetre.perim()</code></p> <p>Ouvrez <code>Perimetre.java</code> et compl\u00e9tez la m\u00e9thode :</p> <pre><code>public class Perimetre {\n    public static int perim(int a, int b, int c) {\n        // TODO: Calculer (a+b)*c en utilisant Addition.add() et Produit.mult()\n        return 0;\n    }\n}\n</code></pre> <p>Test correspondant (<code>PerimetreTest.java</code>) :</p> <pre><code>@Test\npublic void testPerim() {\n    assertEquals(10, Perimetre.perim(2, 3, 2));  // (2+3)*2 = 10\n    assertEquals(0, Perimetre.perim(0, 0, 5));\n    assertEquals(14, Perimetre.perim(3, 4, 2));  // (3+4)*2 = 14\n}\n</code></pre> <p>Indice :</p> <ol> <li>Commencez par additionner <code>a</code> et <code>b</code> avec <code>Addition.add(a, b)</code></li> <li>Multipliez le r\u00e9sultat par <code>c</code> avec <code>Produit.mult()</code></li> </ol> <p>Exemple de solution :</p> <pre><code>int somme = Addition.add(a, b);\nreturn Produit.mult(somme, c);\n</code></pre> <p>V\u00e9rifier :</p> <pre><code>make test\n</code></pre> <p>R\u00e9sultat final attendu :</p> <pre><code>JUnit version 4.13.2\n....\nTime: 0.006\n\nOK (4 tests)\n</code></pre> <p>Tous les tests passent ? Bravo ! Passez \u00e0 l'exercice suivant.</p>"},{"location":"TP-1/#exercice-2-money-addition-avec-validation-de-devises","title":"\u270d\ufe0f Exercice 2 : Money - Addition avec Validation de Devises","text":"<p>\ud83c\udfaf Objectif : Impl\u00e9menter une m\u00e9thode d'addition qui valide que deux montants ont la m\u00eame devise</p> <p>Ouvrez le dossier <code>edl-starter/java-exercises/money/</code></p> <p>Fichiers du projet :</p> <ul> <li><code>Money.java</code> : Classe avec m\u00e9thode <code>add()</code> \u00e0 impl\u00e9menter</li> <li><code>MoneyTest.java</code> : Tests JUnit (certains avec TODOs \u00e0 compl\u00e9ter)</li> </ul> <p>Votre mission :</p> <p>Ouvrez <code>Money.java</code> et impl\u00e9mentez la m\u00e9thode <code>add()</code> :</p> <pre><code>public Money add(Money m) throws Exception {\n    // TODO: V\u00e9rifier si this.currency().equals(m.currency())\n    // TODO: Si oui, retourner new Money(this.amount() + m.amount(), this.currency())\n    // TODO: Si non, throw new Exception(\"Not Same currency\")\n    return null;\n}\n</code></pre> <p>R\u00e8gles m\u00e9tier :</p> <ul> <li>On peut additionner deux montants de m\u00eame devise : <code>12 EUR + 5 EUR = 17 EUR</code></li> <li>On ne peut PAS additionner deux montants de devises diff\u00e9rentes : <code>12 EUR + 5 USD</code> \u2192 Exception</li> </ul> <p>Tests correspondants (<code>MoneyTest.java</code>) :</p> <pre><code>@Test\npublic void testSimpleAdd() throws Exception {\n    Money m12EUR = new Money(12, \"EUR\");\n    Money m14EUR = new Money(14, \"EUR\");\n    Money expected = new Money(26, \"EUR\");\n    assertEquals(expected, m12EUR.add(m14EUR));\n}\n\n@Test(expected = Exception.class)\npublic void testAddDifferentCurrency() throws Exception {\n    Money m12EUR = new Money(12, \"EUR\");\n    Money m5USD = new Money(5, \"USD\");\n    m12EUR.add(m5USD);  // Doit lever une exception\n}\n</code></pre> <p>Indices :</p> <ol> <li>Utilisez <code>this.currency()</code> pour obtenir la devise de l'objet courant</li> <li>Utilisez <code>m.currency()</code> pour obtenir la devise du param\u00e8tre</li> <li>Comparez avec <code>.equals()</code> (pas <code>==</code>)</li> <li>Si les devises sont identiques, cr\u00e9ez un nouveau <code>Money</code> avec la somme des montants</li> <li>Si les devises sont diff\u00e9rentes, lancez une exception avec <code>throw new Exception(\"Not Same currency\")</code></li> </ol> <p>Exemple de solution :</p> <pre><code>public Money add(Money m) throws Exception {\n    if (this.currency().equals(m.currency())) {\n        return new Money(this.amount() + m.amount(), this.currency());\n    }\n    throw new Exception(\"Not Same currency\");\n}\n</code></pre> <p>V\u00e9rifier votre code :</p> <pre><code>cd edl-starter/java-exercises/money\nmake test\n</code></pre> <p>R\u00e9sultat attendu :</p> <pre><code>JUnit version 4.13.2\n....\nTime: 0.007\n\nOK (4 tests)\n</code></pre> <p>Tous les tests passent ? F\u00e9licitations !</p>"},{"location":"TP-1/#comprendre-junit-4-les-bases","title":"\ud83d\udcda Comprendre JUnit 4 - Les Bases","text":"<p>Structure d'un test JUnit :</p> <pre><code>import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ExampleTest {\n\n    @Test\n    public void testMethodName() {\n        // Arrange : Pr\u00e9parer les donn\u00e9es\n        int a = 2;\n        int b = 3;\n\n        // Act : Ex\u00e9cuter la m\u00e9thode \u00e0 tester\n        int result = MyClass.add(a, b);\n\n        // Assert : V\u00e9rifier le r\u00e9sultat\n        assertEquals(5, result);\n    }\n}\n</code></pre> <p>Annotations JUnit :</p> <ul> <li><code>@Test</code> : Indique qu'une m\u00e9thode est un test</li> <li><code>@Test(expected = Exception.class)</code> : Le test passe si l'exception est lev\u00e9e</li> </ul> <p>M\u00e9thodes d'assertion principales :</p> <pre><code>assertEquals(expected, actual);     // V\u00e9rifie que deux valeurs sont \u00e9gales\nassertTrue(condition);              // V\u00e9rifie qu'une condition est vraie\nassertFalse(condition);             // V\u00e9rifie qu'une condition est fausse\nassertNull(object);                 // V\u00e9rifie qu'un objet est null\nassertNotNull(object);              // V\u00e9rifie qu'un objet n'est pas null\n</code></pre> <p>Exemple de test d'exception :</p> <pre><code>@Test(expected = Exception.class)\npublic void testInvalidOperation() throws Exception {\n    Money m1 = new Money(12, \"EUR\");\n    Money m2 = new Money(5, \"USD\");\n    m1.add(m2);  // Cette ligne doit lever une Exception\n}\n</code></pre>"},{"location":"TP-2/","title":"\ud83d\ude80 TP 2 : CI/CD avec GitHub Actions","text":"<p>Pr\u00e9requis : TP 1 termin\u00e9 (backend et frontend avec tests)</p>"},{"location":"TP-2/#objectifs-du-tp","title":"\ud83c\udfaf Objectifs du TP","text":"<p>Objectif principal : Automatiser les tests avec GitHub Actions</p> <p>\u00c0 la fin de ce TP, vous aurez :</p> <ol> <li>\u2705 Cr\u00e9\u00e9 un workflow backend qui teste automatiquement votre code Python</li> <li>\u2705 Cr\u00e9\u00e9 un workflow frontend qui teste et build votre code TypeScript</li> <li>\u2705 Compris comment d\u00e9boguer un workflow qui \u00e9choue</li> <li>\u2705 Prot\u00e9g\u00e9 votre branche main pour emp\u00eacher les bugs d'arriver en production</li> <li>\u2705 Cr\u00e9\u00e9 des workflows r\u00e9utilisables et des pipelines CI</li> <li>\u2705 S\u00e9par\u00e9 les tests rapides (unitaires) des tests lents (E2E)</li> <li>\u2705 Ajout\u00e9 des badges de status \u00e0 votre README</li> </ol>"},{"location":"TP-2/#quest-ce-que-cicd","title":"\ud83d\udce6 Qu'est-ce que CI/CD ?","text":"<p>CI (Continuous Integration) :</p> <ul> <li>Int\u00e9gration Continue</li> <li>\u00c0 chaque push, les tests s'ex\u00e9cutent automatiquement</li> <li>D\u00e9tecte les bugs imm\u00e9diatement</li> </ul> <p>CD (Continuous Deployment) :</p> <ul> <li>D\u00e9ploiement Continu (TP 3)</li> <li>Si les tests passent, d\u00e9ploiement automatique</li> </ul> <p>GitHub Actions :</p> <ul> <li>Service gratuit de GitHub</li> <li>Ex\u00e9cute vos tests sur des serveurs GitHub</li> <li>V\u00e9rifie chaque commit et pull request</li> </ul>"},{"location":"TP-2/#prerequis-verifier-votre-connexion-github","title":"\u2699\ufe0f Pr\u00e9requis : V\u00e9rifier votre connexion GitHub","text":"<p>Avant de commencer, assurez-vous que vous pouvez pousser du code sur votre repository GitHub.</p>"},{"location":"TP-2/#1-allez-dans-votre-repository-clone","title":"1. Allez dans votre repository clon\u00e9","text":"<pre><code>cd chemin/vers/votre/repository\n</code></pre>"},{"location":"TP-2/#2-testez-votre-connexion","title":"2. Testez votre connexion","text":"<pre><code>git push origin main\n</code></pre> <p>R\u00e9sultats possibles :</p> <ul> <li>\u2705 Everything up-to-date \u2192 Parfait, vous \u00eates pr\u00eat !</li> <li>\u274c Error: authentication failed \u2192 Suivez les instructions ci-dessous</li> </ul>"},{"location":"TP-2/#3-configuration-https-si-vous-avez-une-erreur","title":"3. Configuration HTTPS (si vous avez une erreur)","text":""},{"location":"TP-2/#creer-un-personal-access-token-pat","title":"Cr\u00e9er un Personal Access Token (PAT)","text":"<ol> <li>Sur GitHub, allez dans : Settings \u2192 Developer settings \u2192 Personal access tokens \u2192 Tokens (classic)</li> <li>Cliquez sur \"Generate new token (classic)\"</li> <li>Configurez :</li> <li>Note : <code>TP EDL</code></li> <li>Expiration : <code>90 days</code></li> <li>Cochez : \u2705 <code>repo</code> (acc\u00e8s complet aux repositories)</li> <li>Cliquez sur \"Generate token\"</li> <li>\u26a0\ufe0f Copiez le token imm\u00e9diatement (vous ne pourrez plus le revoir !)</li> </ol>"},{"location":"TP-2/#utiliser-le-token","title":"Utiliser le token","text":"<p>Lors du prochain <code>git push</code>, Git vous demandera :</p> <ul> <li>Username : Votre nom d'utilisateur GitHub</li> <li>Password : Collez votre token (PAS votre mot de passe GitHub !)</li> </ul>"},{"location":"TP-2/#structure-dun-workflow-github-actions","title":"\ud83d\udcda Structure d'un Workflow GitHub Actions","text":"<p>Un workflow GitHub Actions est un fichier YAML dans <code>.github/workflows/</code>.</p> <p>Structure de base :</p> <pre><code>name: Mon Workflow          # 1\ufe0f\u20e3 Nom affich\u00e9 dans GitHub\n\non:                         # 2\ufe0f\u20e3 Quand s'ex\u00e9cute-t-il ?\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:                       # 3\ufe0f\u20e3 Les t\u00e2ches \u00e0 faire\n  test:\n    runs-on: ubuntu-latest  # 4\ufe0f\u20e3 Machine virtuelle\n    steps:                  # 5\ufe0f\u20e3 Les \u00e9tapes\n      - uses: actions/checkout@v4\n      - run: pytest\n</code></pre> <p>Concepts cl\u00e9s :</p> <ul> <li><code>name</code> : Nom du workflow</li> <li><code>on</code> : D\u00e9clencheurs (push, pull_request, etc.)</li> <li><code>jobs</code> : T\u00e2ches parall\u00e8les</li> <li><code>steps</code> : \u00c9tapes s\u00e9quentielles</li> <li><code>uses</code> : Action pr\u00e9-faite</li> <li><code>run</code> : Commande shell</li> </ul>"},{"location":"TP-2/#exercice-1-workflow-backend","title":"\u270d\ufe0f Exercice 1 : Workflow Backend","text":""},{"location":"TP-2/#objectif","title":"Objectif","text":"<p>Cr\u00e9er un workflow qui teste automatiquement le backend \u00e0 chaque push.</p>"},{"location":"TP-2/#instructions","title":"Instructions","text":"<ol> <li>Cr\u00e9ez la structure des workflows :</li> </ol> <pre><code>mkdir -p .github/workflows\n</code></pre> <ol> <li>Cr\u00e9ez le fichier <code>.github/workflows/backend.yml</code> avec ce squelette :</li> </ol> <pre><code>name: Backend Tests\n\non:\n  push:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      # TODO : Setup Python 3.11 avec cache pip\n\n      # TODO : Installez UV avec pip\n\n      # TODO : Installez les d\u00e9pendances (cd backend &amp;&amp; uv sync)\n\n      # TODO : Lancez les tests\n</code></pre> <ol> <li>Compl\u00e9tez les TODO en vous aidant de la documentation</li> </ol> <p>\ud83d\udcd6 Documentation utile :    - actions/setup-python : Pour Setup Python avec cache</p> <p>\ud83d\udca1 Indices :    - Setup Python : Utilisez <code>actions/setup-python@v5</code> avec les param\u00e8tres :      - <code>python-version: '3.11'</code>      - <code>cache: 'pip'</code> (pour activer le cache automatique)    - Commandes shell : Utilisez <code>run:</code> suivi de la commande    - Multi-lignes : Utilisez <code>run: |</code> pour ex\u00e9cuter plusieurs commandes</p> <p>Exemple de step avec run :</p> <pre><code>- name: Mon \u00e9tape\n  run: |\n    cd mon-dossier\n    ma-commande\n</code></pre> <ol> <li>Testez localement avant de pousser :</li> </ol> <pre><code>cd backend\nuv run pytest -v --cov\n</code></pre> <ol> <li>Poussez et v\u00e9rifiez sur GitHub Actions :</li> </ol> <pre><code>git add .github/workflows/backend.yml\ngit commit -m \"ci: add backend workflow\"\ngit push origin main\n</code></pre>"},{"location":"TP-2/#resultat-attendu","title":"\u2705 R\u00e9sultat attendu","text":"<p>Dans l'onglet \"Actions\" sur GitHub, vous devriez voir :</p> <pre><code>\u2705 Backend Tests\n  \u2514\u2500 test\n      \u251c\u2500 Checkout code\n      \u251c\u2500 Setup Python\n      \u251c\u2500 Install UV\n      \u251c\u2500 Install dependencies\n      \u2514\u2500 Run tests\n</code></pre>"},{"location":"TP-2/#exercice-2-workflow-frontend","title":"\u270d\ufe0f Exercice 2 : Workflow Frontend","text":""},{"location":"TP-2/#objectif_1","title":"Objectif","text":"<p>Cr\u00e9er un workflow qui teste et build le frontend automatiquement.</p>"},{"location":"TP-2/#instructions_1","title":"Instructions","text":"<ol> <li>Cr\u00e9ez le fichier <code>.github/workflows/frontend.yml</code> avec ce squelette :</li> </ol> <pre><code>name: Frontend Tests\n\non:\n  push:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      # TODO : Setup Node.js 18 avec cache npm\n      # Indice : cache-dependency-path: frontend/package-lock.json\n\n      # TODO : Installez les d\u00e9pendances (cd frontend &amp;&amp; npm ci)\n\n      # TODO : Lancez les tests\n\n      # TODO : V\u00e9rifiez le build\n</code></pre> <ol> <li>Compl\u00e9tez les TODO en vous aidant de la documentation</li> </ol> <p>\ud83d\udcd6 Documentation utile :    - actions/setup-node : Pour Setup Node.js avec cache</p> <p>\ud83d\udca1 Indices :    - Setup Node : Utilisez <code>actions/setup-node@v4</code> avec les param\u00e8tres :      - <code>node-version: '18'</code>      - <code>cache: 'npm'</code>      - <code>cache-dependency-path: frontend/package-lock.json</code>    - npm ci : Installe exactement les versions de <code>package-lock.json</code></p> <ol> <li>Testez localement :</li> </ol> <pre><code>cd frontend\nnpm test -- --run\nnpm run build\n</code></pre> <ol> <li>Poussez et v\u00e9rifiez :</li> </ol> <pre><code>git add .github/workflows/frontend.yml\ngit commit -m \"ci: add frontend workflow\"\ngit push origin main\n</code></pre>"},{"location":"TP-2/#resultat-attendu_1","title":"\u2705 R\u00e9sultat attendu","text":"<p>Vous devriez voir 2 workflows en parall\u00e8le :</p> <pre><code>\u2705 Backend Tests\n\u2705 Frontend Tests\n</code></pre>"},{"location":"TP-2/#note-importante","title":"\ud83d\udca1 Note importante","text":"<p><code>npm ci</code> vs <code>npm install</code> :</p> <ul> <li><code>npm ci</code> : Installe exactement ce qui est dans <code>package-lock.json</code> (d\u00e9terministe)</li> <li><code>npm install</code> : Peut mettre \u00e0 jour les versions (moins fiable pour CI)</li> </ul>"},{"location":"TP-2/#exercice-3-deboguer-un-echec","title":"\u270d\ufe0f Exercice 3 : D\u00e9boguer un \u00c9chec","text":""},{"location":"TP-2/#objectif_2","title":"Objectif","text":"<p>Apprendre \u00e0 lire les logs et corriger les erreurs de workflow.</p>"},{"location":"TP-2/#instructions_2","title":"Instructions","text":"<ol> <li>Introduisez volontairement un bug dans <code>backend/tests/test_api.py</code> :</li> </ol> <pre><code>def test_health_check(client):\n    response = client.get(\"/health\")\n    assert response.status_code == 200\n    assert response.json()[\"status\"] == \"BROKEN\"  # \u274c Faux expr\u00e8s !\n</code></pre> <ol> <li>Poussez le bug :</li> </ol> <pre><code>git add backend/tests/test_api.py\ngit commit -m \"test: intentional failure for learning\"\ngit push origin main\n</code></pre> <ol> <li>Observez l'\u00e9chec sur GitHub Actions :</li> <li>Allez dans \"Actions\"</li> <li>Cliquez sur le workflow \u274c rouge</li> <li> <p>Cliquez sur l'\u00e9tape \"Run tests\"</p> </li> <li> <p>Analysez les logs :</p> </li> <li>Quel test \u00e9choue ?</li> <li>\u00c0 quelle ligne ?</li> <li> <p>Quelle est l'erreur exacte ?</p> </li> <li> <p>Reproduisez localement :</p> </li> </ol> <pre><code>cd backend\nuv run pytest tests/test_api.py::test_health_check -v\n</code></pre> <ol> <li>Corrigez le bug :</li> </ol> <pre><code>assert response.json()[\"status\"] == \"healthy\"  # \u2705 Correct\n</code></pre> <ol> <li>V\u00e9rifiez localement puis poussez :</li> </ol> <pre><code>uv run pytest tests/test_api.py::test_health_check -v\ngit add backend/tests/test_api.py\ngit commit -m \"fix: correct health check assertion\"\ngit push origin main\n</code></pre>"},{"location":"TP-2/#lecon-apprise","title":"\u2705 Le\u00e7on apprise","text":"<p>Si \u00e7a passe localement, \u00e7a passera sur GitHub !</p>"},{"location":"TP-2/#exercice-4-protection-de-branches","title":"\u270d\ufe0f Exercice 4 : Protection de Branches","text":""},{"location":"TP-2/#cest-quoi-une-pull-request-pr","title":"\ud83d\udcd6 C'est quoi une Pull Request (PR) ?","text":"<p>Concept simple : Au lieu de pousser directement sur <code>main</code>, vous cr\u00e9ez une branche, faites vos modifications, puis demandez \u00e0 merger via une Pull Request.</p> <p>Workflow visuel :</p> <pre><code>main \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf  (production, prot\u00e9g\u00e9e)\n                               \u2191\n                          [Pull Request]\n                               \u2502\n                         \u2705 Tests passent ?\n                               \u2502\nfeature/ma-branche \u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2518  (votre travail)\n</code></pre> <p>Avantages :</p> <ul> <li>\u2705 Les tests s'ex\u00e9cutent avant le merge</li> <li>\u2705 Quelqu'un peut review votre code</li> <li>\u2705 La branche <code>main</code> reste stable</li> </ul> <p>Dans cet exercice, vous allez vivre cette situation !</p>"},{"location":"TP-2/#objectif_3","title":"\ud83c\udfaf Objectif","text":"<p>Emp\u00eacher les merges sur <code>main</code> si les tests \u00e9chouent. Vous allez cr\u00e9er une branche avec un bug, ouvrir une PR, et voir GitHub bloquer le merge !</p>"},{"location":"TP-2/#partie-1-activer-la-protection-de-branche","title":"\ud83d\udcd6 Partie 1 : Activer la Protection de Branche","text":"<p>\u26a0\ufe0f Pr\u00e9requis : Vous devez avoir d\u00e9j\u00e0 pouss\u00e9 vos workflows des exercices 1 et 2, et ils doivent avoir tourn\u00e9 au moins une fois.</p> <ol> <li> <p>Sur GitHub, allez dans votre repository \u2192 Settings \u2192 Branches</p> </li> <li> <p>Cliquez sur \"Add branch protection rule\"</p> </li> <li> <p>Configurez ces param\u00e8tres :</p> </li> </ol> <p>a) Branch name pattern    - Entrez : <code>main</code></p> <p>b) Require status checks to pass before merging    - \u2705 Cochez la case \"Require status checks to pass before merging\"    - Dans la barre de recherche qui appara\u00eet, tapez : <code>test</code>    - Cliquez sur <code>test</code> dans les r\u00e9sultats (c'est le nom du job de vos workflows)</p> <p>\ud83d\udca1 Si <code>test</code> n'appara\u00eet pas : Vos workflows n'ont pas encore tourn\u00e9. Retournez sur l'onglet \"Actions\" et v\u00e9rifiez qu'ils ont bien \u00e9t\u00e9 ex\u00e9cut\u00e9s.</p> <ol> <li>Scrollez tout en bas et cliquez sur \"Create\"</li> </ol> <p>\u26a0\ufe0f Important : Ne cochez RIEN d'autre ! Les autres options sont pour des cas avanc\u00e9s.</p>"},{"location":"TP-2/#partie-2-tester-avec-une-branche-qui-casse-les-tests","title":"\ud83e\uddea Partie 2 : Tester avec une Branche Qui Casse les Tests","text":"<p>Sc\u00e9nario r\u00e9aliste : Vous introduisez un bug accidentellement. GitHub doit vous emp\u00eacher de merger !</p> <ol> <li>Cr\u00e9ez une nouvelle branche :</li> </ol> <pre><code>git checkout -b feature/test-branch-protection\n</code></pre> <ol> <li>Introduisez un bug dans <code>backend/tests/test_api.py</code> :</li> </ol> <pre><code>def test_health_check(client):\n    response = client.get(\"/health\")\n    assert response.status_code == 200\n    assert response.json()[\"status\"] == \"BROKEN\"  # \u274c Bug volontaire\n</code></pre> <ol> <li>Commitez et poussez :</li> </ol> <pre><code>git add backend/tests/test_api.py\ngit commit -m \"test: intentionally break health check\"\ngit push origin feature/test-branch-protection\n</code></pre> <ol> <li>Cr\u00e9ez une Pull Request :</li> </ol> <p><pre><code># Si c'est la premi\u00e8re fois, configurez le repo par d\u00e9faut\ngh repo set-default\n# S\u00e9lectionnez VOTRE fork (pas le repo d'origine)\n\n# Cr\u00e9ez la PR\ngh pr create --title \"Test branch protection\" --body \"Testing if broken tests block merge\"\n</code></pre>    \ud83d\udca1 Attention : les commandes <code>gh ...</code> n\u00e9cessitent l\u2019installation de GitHub CLI.    Si vous ne l\u2019avez pas encore, installez-le avant d\u2019ex\u00e9cuter ces commandes.</p> <ol> <li>Observez ce qui se passe :</li> <li>\u23f3 Les workflows s'ex\u00e9cutent automatiquement</li> <li>\u274c Le job <code>test</code> \u00e9choue (tests backend en erreur)</li> <li>\ud83d\udd12 Le bouton \"Merge pull request\" devient gris\u00e9 et inutilisable</li> <li>\u26a0\ufe0f GitHub affiche : \"Required status check 'test' has not been successful\"</li> </ol>"},{"location":"TP-2/#partie-3-corriger-et-merger","title":"\u2705 Partie 3 : Corriger et Merger","text":"<ol> <li>Corrigez le bug (toujours sur la m\u00eame branche) :</li> </ol> <pre><code>assert response.json()[\"status\"] == \"healthy\"  # \u2705 Correct\n</code></pre> <ol> <li>Commitez et poussez la correction :</li> </ol> <pre><code>git add backend/tests/test_api.py\ngit commit -m \"fix: correct health check assertion\"\ngit push origin feature/test-branch-protection\n</code></pre> <ol> <li>Observez la PR :</li> <li>\u2705 Les workflows se relancent automatiquement</li> <li>\u2705 Les tests passent maintenant</li> <li> <p>\u2705 Le bouton \"Merge pull request\" devient vert et cliquable</p> </li> <li> <p>Mergez la PR :</p> </li> <li>Cliquez sur \"Merge pull request\"</li> <li> <p>Confirmez avec \"Confirm merge\"</p> </li> <li> <p>Nettoyez votre environnement local :</p> </li> </ol> <pre><code>git checkout main\ngit pull origin main\ngit branch -d feature/test-branch-protection\n</code></pre>"},{"location":"TP-2/#ce-que-vous-devriez-voir","title":"\ud83d\udcf8 Ce Que Vous Devriez Voir","text":"<p>\u00c9tape 5 - PR bloqu\u00e9e :</p> <pre><code>\u26a0\ufe0f Merging is blocked\n\u274c Required status check \"test\" has not been successful\n\nSome checks were not successful\n\u274c Backend Tests / test \u2014 Failed\n\nThis branch has not been approved\n\ud83d\udd12 Merge blocked\n</code></pre> <p>\u00c9tape 3 (apr\u00e8s fix) - PR d\u00e9bloqu\u00e9e :</p> <pre><code>\u2705 All checks have passed\n\u2705 Backend Tests / test \u2014 Passed\n\u2705 Frontend Tests / test \u2014 Passed\n\nThis branch has no conflicts with the base branch\n\ud83c\udf89 Ready to merge\n</code></pre>"},{"location":"TP-2/#points-cles-a-comprendre","title":"\ud83d\udca1 Points Cl\u00e9s \u00e0 Comprendre","text":"<p>Q1 : Pourquoi est-ce important ?</p> <ul> <li>R : Emp\u00eache les bugs d'arriver en production. Si un d\u00e9veloppeur casse quelque chose, GitHub le force \u00e0 corriger avant de merger.</li> </ul> <p>Q2 : Est-ce que \u00e7a ralentit le d\u00e9veloppement ?</p> <ul> <li>R : Non ! Au contraire, \u00e7a \u00e9vite de perdre du temps \u00e0 d\u00e9boguer en production. \"Fail fast, fix fast\".</li> </ul> <p>Q3 : Peut-on contourner cette protection ?</p> <ul> <li>R : Oui, les admins du repo peuvent forcer le merge. Mais c'est une mauvaise pratique sauf urgence critique.</li> </ul>"},{"location":"TP-2/#exercice-5-workflows-reutilisables","title":"\u270d\ufe0f Exercice 5 : Workflows R\u00e9utilisables","text":""},{"location":"TP-2/#objectif_4","title":"Objectif","text":"<p>Cr\u00e9er un pipeline CI global qui orchestre backend et frontend.</p>"},{"location":"TP-2/#instructions_3","title":"Instructions","text":"<ol> <li>Rendez vos workflows r\u00e9utilisables :</li> </ol> <p>Dans <code>backend.yml</code> et <code>frontend.yml</code>, ajoutez <code>pull_request</code> et <code>workflow_call</code> aux d\u00e9clencheurs :</p> <pre><code>on:\n  push:\n    branches: [main]\n  pull_request:  # \u2728 Nouveau !\n    branches: [main]\n  workflow_call:  # \u2728 Nouveau !\n</code></pre> <ol> <li>Cr\u00e9ez <code>.github/workflows/ci-pipeline.yml</code> :</li> </ol> <pre><code>name: CI Pipeline\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  backend:\n    name: Backend Tests\n    uses: ./.github/workflows/backend.yml\n\n  frontend:\n    name: Frontend Tests\n    uses: ./.github/workflows/frontend.yml\n\n  summary:\n    name: All Tests Passed\n    needs: [backend, frontend]\n    runs-on: ubuntu-latest\n    steps:\n      - name: \ud83c\udf89 Success\n        run: echo \"\ud83c\udf89 Tous les tests sont pass\u00e9s !\"\n</code></pre> <ol> <li>Poussez et observez :</li> </ol> <pre><code>git add .github/workflows/\ngit commit -m \"ci: add reusable workflows and pipeline\"\ngit push origin main\n</code></pre>"},{"location":"TP-2/#resultat","title":"\u2705 R\u00e9sultat","text":"<p>Vous verrez maintenant 3 workflows :</p> <pre><code>\u2705 Backend Tests\n\u2705 Frontend Tests\n\u2705 CI Pipeline (r\u00e9sum\u00e9 global)\n</code></pre> <p>Le job <code>summary</code> attend que backend ET frontend soient termin\u00e9s avant de s'ex\u00e9cuter.</p>"},{"location":"TP-2/#exercice-6-separer-tests-unitaires-et-e2e","title":"\u270d\ufe0f Exercice 6 : S\u00e9parer Tests Unitaires et E2E","text":""},{"location":"TP-2/#objectif_5","title":"Objectif","text":"<p>Ex\u00e9cuter les tests rapides (unitaires) sur toutes les branches, mais les tests lents (E2E) seulement sur <code>main</code>. Les tests E2E (end-to-end) v\u00e9rifient le fonctionnement complet de l\u2019application comme le ferait un utilisateur r\u00e9el (du frontend au backend, base de donn\u00e9es, API, etc.). Ils sont plus lents que les tests unitaires, c\u2019est pourquoi on ne les ex\u00e9cute que sur la branche <code>main</code>.</p>"},{"location":"TP-2/#instructions_4","title":"Instructions","text":"<p>Partie 1 : Marquer les tests E2E</p> <ol> <li>Dans <code>backend/tests/conftest.py</code>, ajoutez :</li> </ol> <pre><code>def pytest_configure(config):\n    \"\"\"Enregistre les markers personnalis\u00e9s\"\"\"\n    config.addinivalue_line(\n        \"markers\",\n        \"e2e: mark test as end-to-end test (slow)\"\n    )\n</code></pre> <ol> <li>Dans <code>backend/tests/test_api.py</code>, cr\u00e9ez un test E2E :</li> </ol> <pre><code>import pytest\n\n@pytest.mark.e2e\ndef test_complete_task_lifecycle(client):\n    \"\"\"Test E2E : Cr\u00e9er plusieurs t\u00e2ches et les lister.\"\"\"\n    # Cr\u00e9er la premi\u00e8re t\u00e2che\n    response = client.post(\"/tasks\", json={\n        \"title\": \"T\u00e2che E2E 1\",\n        \"description\": \"Premi\u00e8re t\u00e2che\"\n    })\n    assert response.status_code == 201\n    task1_id = response.json()[\"id\"]\n\n    # Cr\u00e9er la deuxi\u00e8me t\u00e2che\n    response = client.post(\"/tasks\", json={\n        \"title\": \"T\u00e2che E2E 2\",\n        \"description\": \"Deuxi\u00e8me t\u00e2che\"\n    })\n    assert response.status_code == 201\n    task2_id = response.json()[\"id\"]\n\n    # Lister toutes les t\u00e2ches\n    response = client.get(\"/tasks\")\n    assert response.status_code == 200\n    tasks = response.json()\n    assert len(tasks) &gt;= 2\n\n    # V\u00e9rifier que nos deux t\u00e2ches sont dans la liste\n    task_ids = [task[\"id\"] for task in tasks]\n    assert task1_id in task_ids\n    assert task2_id in task_ids\n</code></pre> <ol> <li>Testez localement les diff\u00e9rentes commandes :</li> </ol> <pre><code>cd backend\n# Tests unitaires seulement\nuv run pytest -v -m \"not e2e\"\n\n# Tests E2E seulement\nuv run pytest -v -m \"e2e\"\n\n# Tous les tests\nuv run pytest -v\n</code></pre> <p>Partie 2 : Modifier le workflow backend pour s\u00e9parer les tests</p> <ol> <li>Modifiez <code>.github/workflows/backend.yml</code> pour ajouter 2 jobs au lieu d'un seul :</li> </ol> <p>Remplacez le contenu complet par :</p> <pre><code>name: Backend Tests\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n  workflow_call:\n\njobs:\n  unit-tests:\n    name: Unit Tests\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: \ud83d\udce5 Checkout code\n        uses: actions/checkout@v4\n\n      - name: \ud83d\udc0d Setup Python 3.11\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n          cache: 'pip'\n\n      - name: \ud83d\udce6 Install UV\n        run: pip install uv\n\n      - name: \ud83d\udcda Install dependencies\n        run: |\n          cd backend\n          uv sync\n\n      - name: \ud83e\uddea Run unit tests only\n        run: |\n          cd backend\n          uv run pytest -v -m \"not e2e\"\n\n  e2e-tests:\n    name: E2E Tests\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'  # \u2728 Seulement sur main !\n    needs: unit-tests\n\n    steps:\n      - name: \ud83d\udce5 Checkout code\n        uses: actions/checkout@v4\n\n      - name: \ud83d\udc0d Setup Python 3.11\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n          cache: 'pip'\n\n      - name: \ud83d\udce6 Install UV\n        run: pip install uv\n\n      - name: \ud83d\udcda Install dependencies\n        run: |\n          cd backend\n          uv sync\n\n      - name: \ud83e\uddea Run E2E tests only\n        run: |\n          cd backend\n          uv run pytest -v -m \"e2e\"\n</code></pre> <p>Changements cl\u00e9s :    - 2 jobs au lieu d'un seul : <code>unit-tests</code> et <code>e2e-tests</code>    - <code>if: github.ref == 'refs/heads/main'</code> \u2192 Le job E2E ne tourne que sur main    - <code>needs: unit-tests</code> \u2192 Les E2E attendent que les tests unitaires passent</p> <ol> <li>Testez le comportement diff\u00e9rent entre PR et main :</li> </ol> <p>\u00c9tape 1 : Tester sur main d'abord</p> <p>Poussez vos changements sur main :</p> <pre><code>git add .\ngit commit -m \"feat: split unit and E2E tests\"\ngit push origin main\n</code></pre> <p>\u2192 Sur GitHub, allez dans Actions \u2192 Cliquez sur le workflow \"Backend Tests\" \u2192 Vous devriez voir les deux jobs : \"Unit Tests\" ET \"E2E Tests\" s'ex\u00e9cuter.</p> <p>\u00c9tape 2 : Tester sur une PR</p> <p>Cr\u00e9ez une branche et une PR pour voir que les E2E ne tournent pas :</p> <pre><code># Assurez-vous d'\u00eatre sur main et \u00e0 jour\ngit checkout main\ngit pull origin main\n\n# Cr\u00e9ez une nouvelle branche\ngit checkout -b test/pr-no-e2e\necho \"# Test PR\" &gt;&gt; README.md\ngit add .\ngit commit -m \"test: verify E2E don't run on PR\"\ngit push origin test/pr-no-e2e\ngh pr create --title \"Test E2E sur PR\" --body \"V\u00e9rifier que E2E ne tourne pas sur PR\"\n</code></pre> <p>\u2192 Sur GitHub, allez dans Actions \u2192 Cliquez sur le workflow \"Backend Tests\" de la PR \u2192 Vous devriez voir seulement le job \"Unit Tests\" s'ex\u00e9cuter (pas de E2E Tests).</p>"},{"location":"TP-2/#resultat-attendu_2","title":"\u2705 R\u00e9sultat attendu","text":"<ul> <li>Sur PR : Seulement le job \"Unit Tests\" s'ex\u00e9cute \u26a1 (rapide)</li> <li>Sur main : Les jobs \"Unit Tests\" ET \"E2E Tests\" s'ex\u00e9cutent \ud83d\udc22 (plus lent mais complet)</li> </ul>"},{"location":"TP-2/#exercice-7-badges-de-status","title":"\u270d\ufe0f Exercice 7 : Badges de Status","text":""},{"location":"TP-2/#objectif_6","title":"Objectif","text":"<p>Afficher le statut des workflows dans votre README.</p>"},{"location":"TP-2/#instructions_5","title":"Instructions","text":"<ol> <li> <p>Modifiez <code>README.md</code> et ajoutez au d\u00e9but : <pre><code># TaskFlow API\n\n![Backend Tests](https://github.com/VOTRE_NOM/VOTRE_REPO/workflows/Backend%20Tests/badge.svg)\n![Frontend Tests](https://github.com/VOTRE_NOM/VOTRE_REPO/workflows/Frontend%20Tests/badge.svg)\n![CI Pipeline](https://github.com/VOTRE_NOM/VOTRE_REPO/workflows/CI%20Pipeline/badge.svg)\n</code></pre></p> </li> <li> <p>Remplacez :</p> </li> <li><code>VOTRE_NOM</code> \u2192 Votre username GitHub</li> <li> <p><code>VOTRE_REPO</code> \u2192 Nom de votre repo</p> </li> <li> <p>Poussez :</p> </li> </ol> <pre><code>git add README.md\ngit commit -m \"docs: add CI badges\"\ngit push origin main\n</code></pre>"},{"location":"TP-2/#resultat_1","title":"\u2705 R\u00e9sultat","text":"<p>Sur GitHub, vous verrez des badges qui se mettent \u00e0 jour automatiquement :</p> <pre><code>\u2705 Backend Tests  \u2705 Frontend Tests  \u2705 CI Pipeline\n</code></pre>"},{"location":"TP-2/#recapitulatif","title":"\ud83d\udccb R\u00e9capitulatif","text":"<p>F\u00e9licitations ! Vous avez maintenant :</p> <p>\u2705 Exercice 1 : Workflow backend automatis\u00e9 (avec cache pip automatique) \u2705 Exercice 2 : Workflow frontend automatis\u00e9 (avec cache npm automatique) \u2705 Exercice 3 : Comp\u00e9tences en d\u00e9bogage de workflows \u2705 Exercice 4 : Protection de branches pour emp\u00eacher les bugs d'arriver en production \u2705 Exercice 5 : Pipeline CI global avec workflows r\u00e9utilisables \u2705 Exercice 6 : S\u00e9paration tests unitaires / E2E \u2705 Exercice 7 : Badges de status dans le README</p>"},{"location":"TP-2/#competences-acquises","title":"\ud83c\udfaf Comp\u00e9tences Acquises","text":"<p>Vous savez maintenant :</p> <ul> <li>\u2705 Cr\u00e9er et configurer des workflows GitHub Actions</li> <li>\u2705 Utiliser le cache automatique pour acc\u00e9l\u00e9rer les builds</li> <li>\u2705 D\u00e9boguer des workflows qui \u00e9chouent</li> <li>\u2705 Prot\u00e9ger la branche <code>main</code> contre les bugs</li> <li>\u2705 Cr\u00e9er des Pull Requests et comprendre le processus de review</li> <li>\u2705 Organiser des pipelines CI complexes</li> <li>\u2705 S\u00e9parer tests rapides et tests lents</li> <li>\u2705 Afficher le statut de vos workflows avec des badges</li> </ul> <p>Ces comp\u00e9tences sont directement utilisables en entreprise ! \ud83d\ude80</p> <p>Temps total estim\u00e9 : 4-5 heures</p>"},{"location":"TP-2/#erreurs-frequentes","title":"\ud83d\udc1b Erreurs Fr\u00e9quentes","text":""},{"location":"TP-2/#uv-command-not-found","title":"\u274c <code>uv: command not found</code>","text":"<p>Cause : UV n'est pas install\u00e9 ou pas dans le PATH Solution : V\u00e9rifiez que vous avez bien <code>pip install uv</code> dans votre workflow</p>"},{"location":"TP-2/#tests-qui-passent-localement-mais-echouent-sur-github","title":"\u274c Tests qui passent localement mais \u00e9chouent sur GitHub","text":"<p>Causes possibles :</p> <ol> <li>Variable d'environnement manquante</li> <li>D\u00e9pendance syst\u00e8me manquante</li> <li>Timezone diff\u00e9rente</li> <li>Version de Python/Node diff\u00e9rente</li> </ol> <p>D\u00e9boguer : Reproduisez exactement les m\u00eames commandes localement avec la m\u00eame version</p>"},{"location":"TP-2/#required-status-check-has-not-been-successful","title":"\u274c \"Required status check has not been successful\"","text":"<p>Cause : Vous avez activ\u00e9 la protection de branche mais les tests \u00e9chouent Solution : C'est normal ! Corrigez vos tests sur la branche, poussez \u00e0 nouveau, et le merge se d\u00e9bloquera</p>"},{"location":"TP-2/#cache-qui-ne-se-restaure-pas","title":"\u274c Cache qui ne se restaure pas","text":"<p>Cause : Le cache pip/npm automatique ne fonctionne que si les fichiers de d\u00e9pendances (<code>requirements.txt</code>, <code>package-lock.json</code>, etc.) n'ont pas chang\u00e9 Solution : C'est normal si vous avez modifi\u00e9 vos d\u00e9pendances. Le cache se reconstruira automatiquement</p>"},{"location":"TP-2/#bonus-workflow-java-optionnel","title":"\ud83c\udf81 BONUS : Workflow Java (Optionnel)","text":"<p>Pour les \u00e9tudiants qui ont fait les exercices Java du TP 1.</p>"},{"location":"TP-2/#objectif_7","title":"Objectif","text":"<p>Tester automatiquement les 3 projets Java (calculator, string-utils, bank-account).</p>"},{"location":"TP-2/#instructions_6","title":"Instructions","text":"<ol> <li>Cr\u00e9ez <code>.github/workflows/java.yml</code> :</li> </ol> <pre><code>name: Java Tests (Optional)\n\non:\n  push:\n    branches: [main]\n    paths:\n      - 'java-exercises/**'\n  pull_request:\n    branches: [main]\n    paths:\n      - 'java-exercises/**'\n  workflow_dispatch:\n\njobs:\n  test:\n    name: Test Java Exercises\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: \ud83d\udce5 Checkout code\n        uses: actions/checkout@v4\n\n      - name: \u2615 Setup Java\n        uses: actions/setup-java@v4\n        with:\n          distribution: 'temurin'\n          java-version: '17'\n\n      - name: \ud83e\uddee Test Calculator\n        working-directory: java-exercises/calculator\n        run: |\n          javac -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar *.java\n          java -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar org.junit.runner.JUnitCore CalculatorTest\n\n      - name: \ud83d\udcdd Test String Utils\n        working-directory: java-exercises/string-utils\n        run: |\n          javac -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar *.java\n          java -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar org.junit.runner.JUnitCore StringUtilsTest\n\n      - name: \ud83c\udfe6 Test Bank Account\n        working-directory: java-exercises/bank-account\n        run: |\n          javac -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar *.java\n          java -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar org.junit.runner.JUnitCore BankAccountTest\n</code></pre>"},{"location":"TP-2/#nouveaux-concepts","title":"Nouveaux concepts","text":"<p><code>paths:</code> - D\u00e9clenchement conditionnel</p> <pre><code>on:\n  push:\n    paths:\n      - 'java-exercises/**'\n</code></pre> <p>Le workflow ne s'ex\u00e9cute que si vous modifiez des fichiers Java.</p> <p><code>workflow_dispatch:</code> - Lancement manuel Vous pouvez lancer le workflow manuellement depuis l'onglet Actions.</p> <p><code>working-directory:</code> - R\u00e9pertoire de travail</p> <pre><code>- name: Test Calculator\n  working-directory: java-exercises/calculator\n</code></pre> <p>Plus propre que d'utiliser <code>cd</code> dans chaque commande.</p>"},{"location":"TP-2/#test","title":"Test","text":"<p>Option 1 : Modifier un fichier Java</p> <pre><code>echo \"// Test CI\" &gt;&gt; java-exercises/calculator/Calculator.java\ngit add java-exercises/\ngit commit -m \"test: trigger Java workflow\"\ngit push\n</code></pre> <p>Option 2 : Lancement manuel</p> <ol> <li>Allez dans \"Actions\" \u2192 \"Java Tests (Optional)\"</li> <li>Cliquez sur \"Run workflow\"</li> <li>S\u00e9lectionnez \"main\" et cliquez \"Run workflow\"</li> </ol>"},{"location":"TP-3/","title":"\ud83d\ude80 TP 3 : Base de Donn\u00e9es et D\u00e9ploiement en Production","text":""},{"location":"TP-3/#objectifs-de-latelier","title":"\ud83c\udfaf Objectifs de l'Atelier","text":"<p>\u00c0 la fin de cet atelier, vous aurez :</p> <ol> <li>\u2705 Migr\u00e9 vers PostgreSQL avec SQLAlchemy ORM</li> <li>\u2705 D\u00e9ploy\u00e9 automatiquement avec render.yaml (Infrastructure as Code)</li> <li>\u2705 Ajout\u00e9 de nouvelles fonctionnalit\u00e9s (comptage de t\u00e2ches)</li> <li>\u2705 V\u00e9rifi\u00e9 le d\u00e9ploiement automatique (Continuous Deployment)</li> </ol>"},{"location":"TP-3/#architecture-cible","title":"\ud83d\udce6 Architecture Cible","text":"<p>Avant (Local - Stockage en m\u00e9moire) :</p> <pre><code>Frontend (localhost:5173) \u2190 \u2192 Backend (localhost:8000)\n                                  \u2193\n                            Liste Python (RAM)\n                            \u274c Donn\u00e9es perdues au red\u00e9marrage\n</code></pre> <p>Apr\u00e8s (Production avec PostgreSQL) :</p> <pre><code>Frontend (Render)                Backend (Render)              Database (Supabase)\ntaskflow-frontend.onrender.com \u2192 taskflow-backend.onrender.com \u2192 PostgreSQL\n         HTTPS                            HTTPS + CORS                500 MB\n                                                                  \u2705 Donn\u00e9es persistantes\n</code></pre>"},{"location":"TP-3/#exercice-1-installer-les-dependances-postgresql","title":"\u270d\ufe0f Exercice 1 : Installer les D\u00e9pendances PostgreSQL","text":""},{"location":"TP-3/#objectif","title":"Objectif","text":"<p>Ajouter SQLAlchemy et le driver PostgreSQL au backend.</p>"},{"location":"TP-3/#instructions","title":"Instructions","text":"<p>Ajoutez les packages n\u00e9cessaires :</p> <pre><code>cd backend\nuv add sqlalchemy psycopg2-binary\n</code></pre>"},{"location":"TP-3/#ce-que-font-ces-packages","title":"\ud83d\udca1 Ce que font ces packages","text":"<ul> <li><code>sqlalchemy</code> : ORM (Object-Relational Mapping) pour Python - permet de manipuler la base de donn\u00e9es avec des objets Python</li> <li><code>psycopg2-binary</code> : Driver PostgreSQL - permet \u00e0 Python de se connecter \u00e0 PostgreSQL</li> </ul>"},{"location":"TP-3/#exercice-2-configurer-la-base-de-donnees","title":"\u270d\ufe0f Exercice 2 : Configurer la Base de Donn\u00e9es","text":""},{"location":"TP-3/#objectif_1","title":"Objectif","text":"<p>Cr\u00e9er le fichier de configuration pour la connexion \u00e0 la base de donn\u00e9es.</p>"},{"location":"TP-3/#instructions_1","title":"Instructions","text":"<p>Cr\u00e9ez le fichier <code>backend/src/database.py</code> :</p> <pre><code>import os\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, declarative_base\n\n# Lire l'URL de la base de donn\u00e9es depuis les variables d'environnement\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite:///./taskflow.db\")\n\n# Configuration du moteur SQLAlchemy\nif DATABASE_URL.startswith(\"sqlite\"):\n    # SQLite (d\u00e9veloppement local)\n    engine = create_engine(\n        DATABASE_URL,\n        connect_args={\"check_same_thread\": False}\n    )\nelse:\n    # PostgreSQL (production)\n    engine = create_engine(\n        DATABASE_URL,\n        pool_size=5,\n        max_overflow=10,\n        pool_pre_ping=True\n    )\n\n# Factory de sessions\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# Base pour les mod\u00e8les ORM\nBase = declarative_base()\n\n\ndef get_db():\n    \"\"\"G\u00e9n\u00e9rateur qui fournit une session de base de donn\u00e9es.\"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n\ndef init_db():\n    \"\"\"Initialise la base de donn\u00e9es en cr\u00e9ant toutes les tables.\"\"\"\n    from . import models  # Import des mod\u00e8les pour cr\u00e9er les tables\n    Base.metadata.create_all(bind=engine)\n</code></pre>"},{"location":"TP-3/#points-importants","title":"\ud83d\udca1 Points importants","text":"<ul> <li><code>DATABASE_URL</code> : URL de connexion (SQLite en local, PostgreSQL en production)</li> <li>Pool de connexions : R\u00e9utilise les connexions pour am\u00e9liorer les performances</li> <li><code>pool_pre_ping</code> : V\u00e9rifie que la connexion est vivante avant de l'utiliser</li> </ul>"},{"location":"TP-3/#exercice-3-creer-le-modele-de-donnees","title":"\u270d\ufe0f Exercice 3 : Cr\u00e9er le Mod\u00e8le de Donn\u00e9es","text":""},{"location":"TP-3/#objectif_2","title":"Objectif","text":"<p>D\u00e9finir le sch\u00e9ma de la table <code>tasks</code> avec SQLAlchemy ORM.</p>"},{"location":"TP-3/#instructions_2","title":"Instructions","text":"<p>Cr\u00e9ez le fichier <code>backend/src/models.py</code> :</p> <pre><code>from enum import Enum\nfrom sqlalchemy import Column, String, DateTime, Enum as SQLEnum\nfrom sqlalchemy.sql import func\n\nfrom .database import Base\n\n\nclass TaskStatus(str, Enum):\n    \"\"\"Statuts possibles d'une t\u00e2che.\"\"\"\n    TODO = \"todo\"\n    IN_PROGRESS = \"in_progress\"\n    DONE = \"done\"\n\n\nclass TaskPriority(str, Enum):\n    \"\"\"Priorit\u00e9s possibles d'une t\u00e2che.\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n\n\nclass TaskModel(Base):\n    \"\"\"Mod\u00e8le SQLAlchemy pour la table tasks.\"\"\"\n    __tablename__ = \"tasks\"\n\n    id = Column(String, primary_key=True, index=True)\n    title = Column(String(200), nullable=False)\n    description = Column(String(1000), nullable=True)\n    status = Column(SQLEnum(TaskStatus), default=TaskStatus.TODO)\n    priority = Column(SQLEnum(TaskPriority), default=TaskPriority.MEDIUM)\n    assignee = Column(String(100), nullable=True)\n    due_date = Column(DateTime, nullable=True)\n    created_at = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())\n</code></pre>"},{"location":"TP-3/#avantages-de-lorm","title":"\ud83d\udca1 Avantages de l'ORM","text":"<ul> <li>Pas besoin d'\u00e9crire du SQL directement</li> <li>Type-safety avec Python</li> <li>Migrations de sch\u00e9ma facilit\u00e9es</li> <li>Timestamps automatiques (<code>created_at</code>, <code>updated_at</code>)</li> </ul>"},{"location":"TP-3/#exercice-4-migrer-lapplication-vers-postgresql","title":"\u270d\ufe0f Exercice 4 : Migrer l'Application vers PostgreSQL","text":""},{"location":"TP-3/#objectif_3","title":"Objectif","text":"<p>Adapter <code>app.py</code> pour utiliser SQLAlchemy au lieu du stockage en m\u00e9moire.</p>"},{"location":"TP-3/#contexte","title":"Contexte","text":"<p>Actuellement, <code>app.py</code> stocke les t\u00e2ches dans un dictionnaire Python (<code>tasks_db</code>). Au red\u00e9marrage du serveur, toutes les donn\u00e9es sont perdues. Nous allons migrer vers SQLAlchemy pour persister les donn\u00e9es dans PostgreSQL.</p>"},{"location":"TP-3/#instructions_3","title":"Instructions","text":"<p>\u00c9tape 1 : Mettre \u00e0 jour les imports</p> <p>Ouvrez <code>backend/src/app.py</code> et ajoutez les imports n\u00e9cessaires (gardez les imports existants !) :</p> <pre><code>from contextlib import asynccontextmanager\nimport uuid\nfrom fastapi import Depends\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import text\n\nfrom .database import get_db, init_db\nfrom .models import TaskModel, TaskStatus, TaskPriority\n</code></pre> <p>\ud83d\udca1 Pourquoi ces imports ?</p> <ul> <li><code>Depends</code> : Injection de d\u00e9pendances FastAPI pour la session DB</li> <li><code>Session</code> : Type de la session SQLAlchemy</li> <li><code>text</code> : Pour ex\u00e9cuter du SQL brut (health check)</li> <li><code>uuid</code> : Pour g\u00e9n\u00e9rer des identifiants uniques</li> </ul> <p>\u00c9tape 2 : Nettoyer le code obsol\u00e8te</p> <p>Cherchez et supprimez ces \u00e9l\u00e9ments dans <code>app.py</code> :</p> <pre><code># \u274c SUPPRIMER : Ces classes (lignes ~31-42)\nclass TaskStatus(str, Enum):\n    TODO = \"todo\"\n    ...\n\nclass TaskPriority(str, Enum):\n    LOW = \"low\"\n    ...\n\n# \u274c SUPPRIMER : Le stockage en m\u00e9moire (lignes ~78-79)\ntasks_db: Dict[int, Task] = {}\nnext_id = 1\n\n# \u274c SUPPRIMER : Ces fonctions (lignes ~82-94)\ndef get_next_id() -&gt; int:\n    ...\n\ndef clear_tasks():\n    ...\n\n# \u26a0\ufe0f \u00c0 MODIFIER : Le health check (sera r\u00e9\u00e9crit \u00e0 l'\u00e9tape 6)\n@app.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"healthy\", \"tasks_count\": len(tasks_db)}\n</code></pre> <p>\ud83d\udca1 Ces \u00e9l\u00e9ments sont maintenant dans <code>models.py</code> ou remplac\u00e9s par SQLAlchemy.</p> <p>\u00c9tape 3 : Remplacer le syst\u00e8me de d\u00e9marrage</p> <p>Cherchez et supprimez les anciens handlers :</p> <pre><code># \u274c SUPPRIMER ces deux fonctions (lignes ~129-139)\n@app.on_event(\"startup\")\ndef startup():\n    ...\n\n@app.on_event(\"shutdown\")\ndef shutdown():\n    ...\n</code></pre> <p>Remplacez-les par le nouveau syst\u00e8me <code>lifespan</code> (\u00e0 placer AVANT la cr\u00e9ation de <code>app</code>) :</p> <pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Lifecycle manager - initialise la DB au d\u00e9marrage.\"\"\"\n    logger.info(\"\ud83d\ude80 TaskFlow backend starting up...\")\n    init_db()  # Cr\u00e9e les tables\n    logger.info(\"\u2705 Database initialized\")\n    yield\n    logger.info(\"\ud83d\uded1 TaskFlow backend shutting down...\")\n\n\napp = FastAPI(\n    title=\"TaskFlow API\",\n    ...\n    lifespan=lifespan,  # \u2190 Ajouter cette ligne\n)\n</code></pre> <p>\u00c9tape 3b : Ajouter le middleware CORS</p> <p>Ajoutez ces imports en haut du fichier (avec les autres imports) :</p> <pre><code>from fastapi.middleware.cors import CORSMiddleware\nimport os\n</code></pre> <p>Puis ajoutez ce code juste apr\u00e8s <code>app = FastAPI(...)</code> :</p> <pre><code># Configuration CORS pour le frontend\ncors_origins_str = os.getenv(\"CORS_ORIGINS\", \"http://localhost:5173,http://localhost:3000\")\ncors_origins = [origin.strip() for origin in cors_origins_str.split(\",\")]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=cors_origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n</code></pre> <p>\u26a0\ufe0f Important : Le middleware CORS est essentiel pour que le frontend puisse communiquer avec le backend en production. La variable <code>CORS_ORIGINS</code> sera configur\u00e9e sur Render \u00e0 l'exercice 7.</p> <p>\u00c9tape 4 : Modifier la classe Task existante</p> <p>Cherchez la classe <code>Task</code> dans <code>app.py</code> et remplacez-la :</p> <pre><code># \u274c AVANT (ne fonctionne plus avec SQLAlchemy)\nclass Task(TaskCreate):\n    id: int  # \u2190 int ne marche pas avec UUID\n    created_at: datetime\n    updated_at: datetime\n\n# \u2705 APR\u00c8S (compatible SQLAlchemy)\nclass Task(BaseModel):\n    \"\"\"Model for task response.\"\"\"\n    id: str  # \u2190 Chang\u00e9 en str pour UUID\n    title: str\n    description: Optional[str] = None\n    status: TaskStatus\n    priority: TaskPriority\n    assignee: Optional[str] = None\n    due_date: Optional[datetime] = None\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True  # Permet la conversion depuis SQLAlchemy\n</code></pre> <p>\ud83d\udca1 Pourquoi ces changements ?</p> <ul> <li><code>id: str</code> au lieu de <code>int</code> \u2192 les UUID sont des strings</li> <li><code>from_attributes = True</code> \u2192 permet \u00e0 Pydantic de lire les objets SQLAlchemy</li> </ul> <p>\u00c9tape 5 : Modifier les endpoints</p> <p>Pour chaque endpoint, ajoutez <code>db: Session = Depends(get_db)</code> comme param\u00e8tre.</p> <p>Exemple simple avec health check :</p> <pre><code># \u26a0\ufe0f AVANT (ne fonctionne plus)\n@app.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"healthy\", \"tasks_count\": len(tasks_db)}\n\n# \u2705 APR\u00c8S (avec SQLAlchemy)\n@app.get(\"/health\")\nasync def health_check(db: Session = Depends(get_db)):\n    \"\"\"Health check with database status.\"\"\"\n    try:\n        db.execute(text(\"SELECT 1\"))\n        tasks_count = db.query(TaskModel).count()\n        return {\n            \"status\": \"healthy\",\n            \"database\": \"connected\",\n            \"tasks_count\": tasks_count\n        }\n    except Exception as e:\n        return {\"status\": \"unhealthy\", \"database\": str(e)}\n</code></pre> <p>\u26a0\ufe0f Attention : <code>db: Session = Depends(get_db)</code> doit \u00eatre dans les param\u00e8tres de la fonction, pas dans le corps !</p> <p>Exemple complet avec GET /tasks :</p> <pre><code>@app.get(\"/tasks\", response_model=List[Task])\nasync def get_tasks(\n    status: Optional[TaskStatus] = None,\n    priority: Optional[TaskPriority] = None,\n    assignee: Optional[str] = None,\n    db: Session = Depends(get_db)  # \u2190 Toujours en dernier dans les param\u00e8tres\n):\n    \"\"\"Get all tasks with optional filtering.\"\"\"\n    query = db.query(TaskModel)\n\n    if status:\n        query = query.filter(TaskModel.status == status)\n    if priority:\n        query = query.filter(TaskModel.priority == priority)\n    if assignee:\n        query = query.filter(TaskModel.assignee == assignee)\n\n    return query.all()\n</code></pre> <p>\u26a0\ufe0f Ne confondez pas <code>Task</code> et <code>TaskModel</code> !</p> Mod\u00e8le Type Utilisation <code>Task</code> Pydantic <code>response_model=Task</code> (r\u00e9ponses API) <code>TaskModel</code> SQLAlchemy <code>db.query(TaskModel)</code>, <code>TaskModel(...)</code> (op\u00e9rations DB) <p>R\u00e8gle simple : Pour tout ce qui touche \u00e0 la base de donn\u00e9es \u2192 <code>TaskModel</code></p> <p>Adaptez chaque endpoint selon ce tableau :</p> Endpoint Logique SQLAlchemy GET /tasks <code>db.query(TaskModel).all()</code> GET /tasks/{id} <code>db.query(TaskModel).filter(TaskModel.id == task_id).first()</code> POST /tasks <code>TaskModel(id=str(uuid.uuid4()), ...)</code> \u2192 <code>db.add()</code> \u2192 <code>db.commit()</code> \u2192 <code>db.refresh()</code> PUT /tasks/{id} <code>setattr(task, field, value)</code> \u2192 <code>db.commit()</code> \u2192 <code>db.refresh(task)</code> DELETE /tasks/{id} <code>db.delete(task)</code> \u2192 <code>db.commit()</code> <p>\ud83d\udca1 Pattern SQLAlchemy :</p> <ol> <li><code>db.add(obj)</code> - Ajoute \u00e0 la session</li> <li><code>db.commit()</code> - Sauvegarde en base</li> <li><code>db.refresh(obj)</code> - Recharge les valeurs g\u00e9n\u00e9r\u00e9es (timestamps, etc.)</li> </ol> <p>Indice POST /tasks : Cr\u00e9ez un <code>TaskModel</code> (pas <code>Task</code>) avec <code>id=str(uuid.uuid4())</code> au lieu de <code>get_next_id()</code></p>"},{"location":"TP-3/#points-cles-a-retenir","title":"\ud83d\udca1 Points cl\u00e9s \u00e0 retenir","text":"Concept Explication <code>Depends(get_db)</code> FastAPI injecte automatiquement une session DB <code>db.commit()</code> Obligatoire pour sauvegarder les changements <code>db.refresh()</code> Recharge l'objet avec les valeurs de la DB (timestamps) <code>from_attributes = True</code> Permet \u00e0 Pydantic de lire les attributs SQLAlchemy"},{"location":"TP-3/#checkpoint","title":"\u2705 Checkpoint","text":"<p>Testez localement :</p> <pre><code>cd backend\nuv run uvicorn src.app:app --reload\n\n# Dans un autre terminal\ncurl http://localhost:8000/health\ncurl http://localhost:8000/tasks\n</code></pre> <p>Vous devriez voir un fichier <code>taskflow.db</code> cr\u00e9\u00e9 dans <code>backend/</code></p>"},{"location":"TP-3/#exercice-5-adapter-les-tests","title":"\u270d\ufe0f Exercice 5 : Adapter les Tests","text":""},{"location":"TP-3/#objectif_4","title":"Objectif","text":"<p>Modifier les tests pour utiliser une base de donn\u00e9es SQLite temporaire.</p>"},{"location":"TP-3/#contexte_1","title":"Contexte","text":"<p>Les tests utilisent actuellement <code>clear_tasks()</code> qui n'existe plus. Nous devons cr\u00e9er une base de donn\u00e9es de test isol\u00e9e et nettoyer les donn\u00e9es entre chaque test.</p>"},{"location":"TP-3/#instructions_4","title":"Instructions","text":"<p>Remplacez le contenu de <code>backend/tests/conftest.py</code> par :</p> <pre><code>import pytest\nimport tempfile\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import StaticPool\n\nfrom src.app import app\nfrom src.database import Base, get_db\nfrom src.models import TaskModel\n\nTEST_DB_FILE = tempfile.mktemp(suffix=\".db\")\nTEST_DATABASE_URL = f\"sqlite:///{TEST_DB_FILE}\"\n\ntest_engine = create_engine(\n    TEST_DATABASE_URL,\n    connect_args={\"check_same_thread\": False},\n    poolclass=StaticPool,\n)\n\nTestSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)\n\n\n@pytest.fixture(scope=\"session\")\ndef setup_test_database():\n    \"\"\"Cr\u00e9e les tables une seule fois pour tous les tests.\"\"\"\n    Base.metadata.create_all(bind=test_engine)\n    yield\n    Base.metadata.drop_all(bind=test_engine)\n\n\n@pytest.fixture(autouse=True)\ndef clear_test_data(setup_test_database):\n    \"\"\"Nettoie les donn\u00e9es entre chaque test.\"\"\"\n    db = TestSessionLocal()\n    db.query(TaskModel).delete()\n    db.commit()\n    db.close()\n\n\n@pytest.fixture\ndef client(setup_test_database):\n    \"\"\"Client de test avec base de donn\u00e9es isol\u00e9e.\"\"\"\n    def override_get_db():\n        db = TestSessionLocal()\n        try:\n            yield db\n        finally:\n            db.close()\n\n    app.dependency_overrides[get_db] = override_get_db\n    with TestClient(app) as c:\n        yield c\n    app.dependency_overrides.clear()\n</code></pre> <p>\ud83d\udca1 <code>dependency_overrides</code> permet de remplacer <code>get_db</code> par une version qui utilise la base de test au lieu de la vraie base.</p>"},{"location":"TP-3/#checkpoint_1","title":"\u2705 Checkpoint","text":"<pre><code>cd backend\nuv run pytest -v\n</code></pre> <p>Tous les tests doivent passer (19+ tests)</p>"},{"location":"TP-3/#exercice-6-configurer-supabase-base-de-donnees","title":"\u270d\ufe0f Exercice 6 : Configurer Supabase (Base de Donn\u00e9es)","text":""},{"location":"TP-3/#objectif_5","title":"Objectif","text":"<p>Cr\u00e9er une base de donn\u00e9es PostgreSQL gratuite sur Supabase.</p>"},{"location":"TP-3/#instructions_5","title":"Instructions","text":"<p>\u00c9tape 1 : Cr\u00e9er un compte Supabase</p> <ol> <li>Allez sur https://supabase.com</li> <li>Cliquez \"Start your project\"</li> <li>Inscrivez-vous avec votre compte GitHub</li> </ol> <p>\u00c9tape 2 : Cr\u00e9er un projet</p> <ol> <li>Cliquez \"New project\"</li> <li>Configurez le projet :</li> <li>Name : <code>taskflow</code></li> <li>Database Password : Choisissez un mot de passe fort (\u26a0\ufe0f notez-le !)</li> <li>Region : <code>West EU (Ireland)</code> (le plus proche)</li> <li>Cliquez \"Create new project\"</li> <li>Attendez la cr\u00e9ation (1-2 minutes)</li> </ol> <p>Apr\u00e8s la cr\u00e9ation, vous arriverez sur la page d'accueil du projet :</p> <p></p> <p>\u00c9tape 3 : R\u00e9cup\u00e9rer la DATABASE_URL</p> <ol> <li>Cliquez sur le bouton \"Connect\" en haut (visible dans le header)</li> </ol> <p></p> <ol> <li>Dans l'onglet Connection String :</li> <li>V\u00e9rifiez que Type = <code>URI</code></li> <li>Changez Method : <code>Session pooler</code> (au lieu de \"Direct connection\")</li> </ol> <p>\u26a0\ufe0f Important : Render utilise IPv4, mais la connexion directe Supabase n\u00e9cessite IPv6. Le Session Pooler r\u00e9sout ce probl\u00e8me.</p> <ol> <li>Copiez l'URL affich\u00e9e</li> <li>Important : Remplacez <code>[YOUR-PASSWORD]</code> par le mot de passe que vous avez choisi \u00e0 l'\u00e9tape 2</li> </ol> <p>L'URL ressemble \u00e0 :</p> <pre><code>postgresql://postgres.[PROJECT-ID]:[YOUR-PASSWORD]@aws-0-eu-west-1.pooler.supabase.com:5432/postgres\n</code></pre> <p>\ud83d\udca1 Notez le host pooler.supabase.com (au lieu de db.xxx.supabase.co).</p> <p>\u26a0\ufe0f Gardez cette URL ! Vous en aurez besoin pour l'exercice 7.</p>"},{"location":"TP-3/#pourquoi-supabase","title":"\ud83d\udca1 Pourquoi Supabase ?","text":"Avantage Description Gratuit 500 MB de stockage PostgreSQL Base de donn\u00e9es professionnelle Interface web Explorer les donn\u00e9es facilement Pas de carte bancaire Contrairement \u00e0 d'autres services"},{"location":"TP-3/#exercice-7-deployer-sur-render","title":"\u270d\ufe0f Exercice 7 : D\u00e9ployer sur Render","text":""},{"location":"TP-3/#objectif_6","title":"Objectif","text":"<p>D\u00e9ployer le backend et le frontend sur Render. Deux m\u00e9thodes sont propos\u00e9es.</p>"},{"location":"TP-3/#prerequis","title":"Pr\u00e9requis","text":"<ol> <li>Cr\u00e9er un compte Render : https://render.com</li> <li>Inscrivez-vous avec GitHub et autorisez l'acc\u00e8s \u00e0 vos repositories</li> <li>Poussez vos changements sur GitHub :</li> </ol> <pre><code>git add .\ngit commit -m \"feat: migrate to PostgreSQL with SQLAlchemy\"\ngit push origin main\n</code></pre>"},{"location":"TP-3/#option-a-deploiement-manuel-via-dashboard","title":"Option A : D\u00e9ploiement Manuel (via Dashboard)","text":"<p>Cette m\u00e9thode vous permet de comprendre chaque \u00e9tape du d\u00e9ploiement.</p> <p>\u00c9tape 1 : D\u00e9ployer le Backend</p> <ol> <li>Sur Render Dashboard, cliquez \"New +\" \u2192 \"Web Service\"</li> <li>Connectez votre repository GitHub</li> <li>Configurez le service :</li> </ol> Param\u00e8tre Valeur Name <code>taskflow-backend</code> Region <code>Frankfurt (EU Central)</code> Branch <code>main</code> Root Directory <code>backend</code> Runtime <code>Python 3</code> Build Command <code>pip install uv &amp;&amp; uv sync</code> Start Command <code>uv run uvicorn src.app:app --host 0.0.0.0 --port $PORT</code> Instance Type <code>Free</code> <p>\ud83d\udca1 <code>$PORT</code> est d\u00e9fini automatiquement par Render - ne pas le remplacer !</p> <ol> <li>Dans la section Environment Variables, ajoutez :</li> </ol> Name Value <code>DATABASE_URL</code> L'URL Supabase de l'exercice 6 <p>\u26a0\ufe0f <code>CORS_ORIGINS</code> sera ajout\u00e9 apr\u00e8s le d\u00e9ploiement du frontend (\u00e9tape 3)</p> <ol> <li>Cliquez \"Create Web Service\"</li> </ol> <p>\u00c9tape 2 : D\u00e9ployer le Frontend</p> <ol> <li>Cliquez \"New +\" \u2192 \"Static Site\"</li> <li>Connectez le m\u00eame repository</li> <li>Configurez :</li> </ol> Param\u00e8tre Valeur Name <code>taskflow-frontend</code> Branch <code>main</code> Root Directory <code>frontend</code> Build Command <code>npm ci &amp;&amp; npm run build</code> Publish Directory <code>dist</code> <ol> <li>Dans la section Environment Variables, ajoutez :</li> </ol> Name Value <code>VITE_API_URL</code> <code>https://edl-starter.onrender.com</code> (URL du backend) <ol> <li>Cliquez \"Create Static Site\"</li> </ol> <p>\u00c9tape 3 : Configurer CORS (apr\u00e8s d\u00e9ploiement)</p> <p>Une fois les deux services d\u00e9ploy\u00e9s, retournez dans le Backend :</p> <ol> <li>Dashboard \u2192 taskflow-backend \u2192 Environment</li> <li>Ajoutez la variable :</li> </ol> Name Value <code>CORS_ORIGINS</code> <code>https://taskflow-frontend-XXXX.onrender.com</code> <ol> <li>Cliquez \"Save Changes\" \u2192 Le backend red\u00e9marre automatiquement</li> </ol>"},{"location":"TP-3/#option-b-deploiement-avec-yaml-infrastructure-as-code","title":"Option B : D\u00e9ploiement avec YAML (Infrastructure as Code)","text":"<p>Cette m\u00e9thode automatise le d\u00e9ploiement via un fichier de configuration.</p> <p>\u00c9tape 1 : Cr\u00e9er <code>render.yaml</code> \u00e0 la racine du projet</p> <pre><code>services:\n  # Backend FastAPI\n  - type: web\n    name: taskflow-backend\n    runtime: python\n    region: frankfurt\n    plan: free\n    buildCommand: pip install uv &amp;&amp; uv sync\n    startCommand: uv run uvicorn src.app:app --host 0.0.0.0 --port $PORT\n    rootDir: backend\n    envVars:\n      - key: DATABASE_URL\n        sync: false  # Configur\u00e9 manuellement\n      - key: CORS_ORIGINS\n        sync: false\n    healthCheckPath: /health\n\n  # Frontend React\n  - type: web\n    name: taskflow-frontend\n    runtime: static\n    buildCommand: npm ci &amp;&amp; npm run build\n    staticPublishPath: ./dist\n    rootDir: frontend\n    envVars:\n      - key: VITE_API_URL\n        sync: false\n</code></pre> <p>\u00c9tape 2 : D\u00e9ployer avec Blueprint</p> <ol> <li>Poussez le fichier <code>render.yaml</code> sur GitHub</li> <li>Sur Render Dashboard : \"New +\" \u2192 \"Blueprint\"</li> <li>S\u00e9lectionnez votre repository</li> <li>Render d\u00e9tecte automatiquement <code>render.yaml</code></li> <li>Cliquez \"Apply\"</li> </ol> <p>\u00c9tape 3 : Configurer les Variables d'Environnement</p> <p>M\u00eame configuration que l'Option A (voir ci-dessus).</p>"},{"location":"TP-3/#comparaison-des-deux-methodes","title":"\ud83d\udca1 Comparaison des deux m\u00e9thodes","text":"Aspect Option A (Manuel) Option B (YAML) Apprentissage \u2705 Meilleur pour comprendre \u26a1 Plus rapide Reproductibilit\u00e9 \u274c Manuel \u00e0 chaque fois \u2705 Versionn\u00e9 dans Git Production \u274c Pas recommand\u00e9 \u2705 Best practice"},{"location":"TP-3/#resultat-attendu","title":"\u2705 R\u00e9sultat attendu","text":"<p>Apr\u00e8s d\u00e9ploiement, notez vos URLs :</p> <pre><code>Backend:  https://edl-starter.onrender.com\nFrontend: https://taskflow-frontend-YYYY.onrender.com\n</code></pre>"},{"location":"TP-3/#pendant-lattente-3-5-minutes","title":"\u23f3 Pendant l'attente (3-5 minutes)","text":"<p>Observez les logs de build en temps r\u00e9el pour chaque service.</p>"},{"location":"TP-3/#exercice-8-verifier-le-deploiement","title":"\u270d\ufe0f Exercice 8 : V\u00e9rifier le D\u00e9ploiement","text":""},{"location":"TP-3/#objectif_7","title":"Objectif","text":"<p>Tester que tout fonctionne en production.</p>"},{"location":"TP-3/#instructions_6","title":"Instructions","text":"<ol> <li>Testez l'API Backend :</li> </ol> <pre><code># Health check\ncurl https://edl-starter.onrender.com/health\n</code></pre> <p>Vous devriez voir :</p> <pre><code>{\n  \"status\": \"healthy\",\n  \"database\": \"connected\",\n  \"tasks_count\": 0,\n  \"environment\": \"production\"\n}\n</code></pre> <ol> <li>Cr\u00e9ez une t\u00e2che :</li> </ol> <pre><code>curl -X POST https://edl-starter.onrender.com/tasks \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"Test production\",\n    \"status\": \"todo\",\n    \"priority\": \"high\"\n  }'\n</code></pre> <ol> <li>Listez les t\u00e2ches :</li> </ol> <pre><code>curl https://edl-starter.onrender.com/tasks\n</code></pre> <ol> <li>Testez le Frontend :</li> <li>Ouvrez <code>https://taskflow-frontend-YYYY.onrender.com</code></li> <li>Cr\u00e9ez plusieurs t\u00e2ches</li> <li>Modifiez une t\u00e2che</li> <li>Supprimez une t\u00e2che</li> </ol>"},{"location":"TP-3/#resultat-attendu_1","title":"\u2705 R\u00e9sultat attendu","text":"<p>Tout fonctionne parfaitement! \ud83c\udf89</p>"},{"location":"TP-3/#recapitulatif","title":"\ud83d\udccb R\u00e9capitulatif","text":"<p>F\u00e9licitations ! Vous avez maintenant :</p> <p>\u2705 Exercice 1 : Install\u00e9 SQLAlchemy et psycopg2 \u2705 Exercice 2 : Configur\u00e9 la connexion \u00e0 la base de donn\u00e9es \u2705 Exercice 3 : Cr\u00e9\u00e9 le mod\u00e8le ORM TaskModel \u2705 Exercice 4 : Migr\u00e9 app.py vers PostgreSQL \u2705 Exercice 5 : Adapt\u00e9 les tests avec une DB temporaire \u2705 Exercice 6 : Configur\u00e9 Supabase (base de donn\u00e9es PostgreSQL) \u2705 Exercice 7 : D\u00e9ploy\u00e9 sur Render \u2705 Exercice 8 : V\u00e9rifi\u00e9 le d\u00e9ploiement en production</p> <p>Temps total estim\u00e9 : 2h30</p>"},{"location":"TP-3/#ce-que-vous-avez-appris","title":"\ud83d\udcda Ce que Vous Avez Appris","text":"<p>\u2705 SQLAlchemy ORM - Mod\u00e8les Python \u2194 Tables SQL \u2705 PostgreSQL - Base de donn\u00e9es relationnelle professionnelle \u2705 D\u00e9ploiement Cloud - Backend et Frontend sur Render \u2705 Base de donn\u00e9es manag\u00e9e - Supabase pour PostgreSQL \u2705 Variables d'environnement - Configuration production vs d\u00e9veloppement \u2705 CORS - Communication cross-origin frontend/backend</p>"}]}