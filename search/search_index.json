{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udf93 EDL: Expertises digitale et logicielle","text":"<p>Bienvenue dans les travaux pratiques d'\u00c9volution et D\u00e9ploiement Logiciel de l'UMONS!</p>"},{"location":"#objectifs-du-cours","title":"\ud83c\udfaf Objectifs du Cours","text":"<p>Ces travaux pratiques vous apprendront les pratiques du d\u00e9veloppement logiciel moderne :</p> <ul> <li>\u2705 Tests automatis\u00e9s (unitaires, int\u00e9gration, E2E)</li> <li>\u2705 CI/CD (Int\u00e9gration et D\u00e9ploiement Continus)</li> <li>\u2705 GitHub Actions (workflows automatis\u00e9s)</li> <li>\u2705 D\u00e9ploiement en production (avec bases de donn\u00e9es r\u00e9elles)</li> <li>\u2705 Bonnes pratiques (TDD, protection de branche, code review)</li> </ul>"},{"location":"#les-3-travaux-pratiques","title":"\ud83d\udcda Les 3 Travaux Pratiques","text":""},{"location":"#tp-1-tests-unitaires-backend-frontend","title":"TP 1 : Tests Unitaires Backend &amp; Frontend","text":"<p>Objectif : Ma\u00eetriser les tests unitaires avec pytest (Python) et Vitest (TypeScript)</p> <p>Ce que vous allez apprendre :</p> <ul> <li>\ud83d\udc0d Tests backend avec pytest et FastAPI</li> <li>\u269b\ufe0f Tests frontend avec Vitest et React</li> <li>\ud83c\udfad Mocking : simuler des API, des bases de donn\u00e9es</li> <li>\u2615 Bonus Java : Tests avec JUnit 4</li> </ul> <p>Technologies : <code>Python</code> \u00b7 <code>TypeScript</code> \u00b7 <code>pytest</code> \u00b7 <code>Vitest</code> \u00b7 <code>FastAPI</code> \u00b7 <code>React</code> \u00b7 <code>JUnit</code></p>"},{"location":"#tp-2-cicd-avec-github-actions","title":"TP 2 : CI/CD avec GitHub Actions","text":"<p>Objectif : Automatiser les tests et le d\u00e9ploiement avec GitHub Actions</p> <p>Ce que vous allez apprendre :</p> <ul> <li>\ud83d\udd04 Workflows GitHub Actions (backend, frontend, full-stack)</li> <li>\ud83d\ude80 CI Pipeline : Tests automatiques \u00e0 chaque commit</li> <li>\ud83d\udd12 Protection de branche : Bloquer les merges si tests \u00e9chouent</li> <li>\u26a1 Optimisation : Cache, jobs parall\u00e8les, tests rapides/lents</li> <li>\ud83c\udfaf Reusable Workflows : Orchestrer plusieurs workflows</li> </ul> <p>Technologies : <code>GitHub Actions</code> \u00b7 <code>YAML</code> \u00b7 <code>CI/CD</code> \u00b7 <code>Workflows</code></p>"},{"location":"#tp-3-deploiement-en-production","title":"TP 3 : D\u00e9ploiement en Production","text":"<p>Objectif : D\u00e9ployer l'application sur Render avec PostgreSQL</p> <p>Ce que vous allez apprendre :</p> <ul> <li>\ud83d\udc18 PostgreSQL : Migrer de la m\u00e9moire \u00e0 une vraie base de donn\u00e9es</li> <li>\ud83d\ude80 Render : D\u00e9ployer backend + frontend + base de donn\u00e9es</li> <li>\ud83d\udd10 Variables d'environnement et secrets</li> <li>\ud83d\udcca Monitoring : Logs, m\u00e9triques, sant\u00e9 de l'application</li> <li>\u267b\ufe0f CD : D\u00e9ploiement automatique apr\u00e8s chaque merge</li> </ul> <p>Technologies : <code>PostgreSQL</code> \u00b7 <code>Render</code> \u00b7 <code>Environment Variables</code> \u00b7 <code>CD</code></p>"},{"location":"#commencer","title":"\ud83d\ude80 Commencer","text":""},{"location":"#prerequis","title":"Pr\u00e9requis","text":"<ul> <li>\u2705 Git install\u00e9</li> <li>\u2705 Python 3.11+ ou UV</li> <li>\u2705 Node.js 18+</li> <li>\u2705 Compte GitHub</li> <li>\u2705 Java 17+ pour les exercices bonus</li> </ul>"},{"location":"#installation","title":"Installation","text":"<ol> <li> <p>Forker le repository : github.com/umons-ig/edl-starter</p> </li> <li> <p>Cloner votre fork :</p> </li> </ol> <pre><code>git clone https://github.com/VOTRE_NOM/edl-starter\ncd edl-starter\n</code></pre> <ol> <li>Suivre le TP 1 pour installer les d\u00e9pendances</li> </ol>"},{"location":"#navigation","title":"\ud83d\udcd6 Navigation","text":"<p>Utilisez le menu de gauche pour naviguer entre les diff\u00e9rents travaux pratiques.</p> <p>Chaque TP est ind\u00e9pendant mais suit une progression logique :</p> <pre><code>TP 1 (Tests) \u2192 TP 2 (CI/CD) \u2192 TP 3 (D\u00e9ploiement)\n</code></pre>"},{"location":"#stack-technique","title":"\ud83d\udee0\ufe0f Stack Technique","text":"<p>Backend :</p> <ul> <li>FastAPI (Python)</li> <li>pytest pour les tests</li> <li>UV pour la gestion des d\u00e9pendances</li> <li>PostgreSQL en production</li> </ul> <p>Frontend :</p> <ul> <li>React + TypeScript</li> <li>Vite pour le build</li> <li>Vitest pour les tests</li> <li>TailwindCSS pour le style</li> </ul> <p>DevOps :</p> <ul> <li>GitHub Actions pour CI/CD</li> <li>Render pour le d\u00e9ploiement</li> <li>MkDocs pour la documentation</li> </ul> <p>Pr\u00eat \u00e0 commencer ? \ud83d\udc49 TP 1 : Tests Unitaires</p>"},{"location":"TP-1/","title":"\ud83c\udf93 TP 1 : Tests Unitaires Backend &amp; Frontend","text":"<p>Objectif : Apprendre les tests unitaires avec Python (pytest) et TypeScript (Vitest)</p>"},{"location":"TP-1/#phase-1-installation-configuration","title":"Phase 1 : Installation &amp; Configuration","text":""},{"location":"TP-1/#etape-11-forker-le-depot","title":"\u00c9tape 1.1 : Forker le D\u00e9p\u00f4t","text":"<ol> <li>Allez sur <code>https://github.com/umons-ig/edl-starter</code></li> <li>Cliquez sur \"Fork\"</li> </ol> <ol> <li>Clonez votre fork :</li> </ol> <pre><code>git clone https://github.com/VOTRE_NOM/edl-starter\ncd edl-starter\n</code></pre>"},{"location":"TP-1/#etape-12-installer-les-dependances-python-2-options","title":"\u00c9tape 1.2 : Installer les D\u00e9pendances Python (2 Options)","text":"<p>Option A : Avec UV (Recommand\u00e9 - Plus Rapide) \u26a1</p> <p>UV est un gestionnaire de paquets Python moderne et ultra-rapide.</p> <p>Installation UV :</p> <p>macOS/Linux :</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Windows :</p> <pre><code>powershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>Installer les d\u00e9pendances :</p> <pre><code>cd backend\nuv venv\nsource .venv/bin/activate  # Windows: .venv\\Scripts\\activate\nuv sync\n</code></pre> <p>Option B : Avec pip (Classique) \ud83d\udc0d</p> <p>Si vous pr\u00e9f\u00e9rez pip ou avez d\u00e9j\u00e0 Python install\u00e9 :</p> <pre><code>cd backend\npython -m venv .venv\nsource .venv/bin/activate  # Windows: .venv\\Scripts\\activate\npip install -r requirements.txt\n</code></pre> <p>Dans le reste de l'atelier :</p> <ul> <li>Si vous utilisez UV : <code>uv run pytest</code></li> <li>Si vous utilisez pip : <code>pytest</code></li> </ul>"},{"location":"TP-1/#phase-2-explorer-lapplication","title":"Phase 2 : Explorer l'Application","text":""},{"location":"TP-1/#etape-21-lancer-le-serveur","title":"\u00c9tape 2.1 : Lancer le Serveur","text":"<pre><code>uv run uvicorn src.app:app --reload\n</code></pre>"},{"location":"TP-1/#etape-22-tester-dans-le-navigateur","title":"\u00c9tape 2.2 : Tester dans le Navigateur","text":"<p>Visitez :</p> <ul> <li>API : http://localhost:8000</li> <li>Documentation interactive : http://localhost:8000/docs</li> <li>Sant\u00e9 : http://localhost:8000/health</li> </ul>"},{"location":"TP-1/#etape-23-tester-avec-swagger-ui","title":"\u00c9tape 2.3 : Tester avec Swagger UI","text":"<ol> <li>Allez sur http://localhost:8000/docs</li> <li>Cliquez sur POST /tasks</li> <li>Cliquez sur \"Try it out\"</li> <li>Entrez :</li> </ol> <pre><code>{\n  \"title\": \"Ma premi\u00e8re t\u00e2che\",\n  \"description\": \"Apprendre FastAPI\"\n}\n</code></pre> <ol> <li>Cliquez sur \"Execute\"</li> <li>Vous devriez voir un code <code>201 Created</code></li> </ol>"},{"location":"TP-1/#etape-24-explorer-le-code","title":"\u00c9tape 2.4 : Explorer le Code","text":"<p>Ouvrez <code>backend/src/app.py</code> dans votre \u00e9diteur :</p> <ul> <li>Lignes 27-36 : \u00c9num\u00e9rations (TaskStatus, TaskPriority)</li> <li>Lignes 39-68 : Mod\u00e8les Pydantic</li> <li>Lignes 76-77 : Stockage en m\u00e9moire (dictionnaire simple)</li> <li>Lignes 180-205 : Endpoint pour cr\u00e9er une t\u00e2che</li> <li>Lignes 144-160 : Endpoint pour lister les t\u00e2ches</li> </ul> <p>Important : Ce backend utilise un stockage en m\u00e9moire (un simple dictionnaire Python) pour TP 1 &amp; 2. Vous apprendrez \u00e0 utiliser PostgreSQL dans l'TP 3.</p>"},{"location":"TP-1/#phase-3-comprendre-les-tests","title":"Phase 3 : Comprendre les Tests","text":""},{"location":"TP-1/#etape-31-explorer-les-fichiers-de-test","title":"\u00c9tape 3.1 : Explorer les Fichiers de Test","text":"<p>Ouvrez ces fichiers :</p> <ul> <li><code>backend/tests/conftest.py</code> \u2192 Fixtures de test</li> <li><code>backend/tests/test_api.py</code> \u2192 Tests</li> </ul>"},{"location":"TP-1/#etape-32-quest-ce-quune-fixture","title":"\u00c9tape 3.2 : Qu'est-ce qu'une Fixture ?","text":"<p>Dans <code>conftest.py</code>, regardez :</p> <pre><code>@pytest.fixture(autouse=True)\ndef clean_tasks():\n    \"\"\"Nettoie les t\u00e2ches avant et apr\u00e8s chaque test\"\"\"\n    clear_tasks()\n    yield\n    clear_tasks()\n\n@pytest.fixture\ndef client():\n    \"\"\"Fournit un client HTTP de test\"\"\"\n    with TestClient(app) as test_client:\n        yield test_client\n</code></pre> <p>Pourquoi c'est utile ?</p> <ul> <li><code>clean_tasks</code> : Nettoie automatiquement le stockage en m\u00e9moire avant chaque test</li> <li><code>client</code> : Vous n'avez pas \u00e0 cr\u00e9er un client dans chaque test</li> <li>pytest les injecte automatiquement quand vous \u00e9crivez <code>def test_xxx(client):</code></li> </ul>"},{"location":"TP-1/#etape-33-lancer-les-tests-existants","title":"\u00c9tape 3.3 : Lancer les Tests Existants","text":"<pre><code>uv run pytest -v\n</code></pre> <p>Vous devriez voir :</p> <pre><code>tests/test_api.py::test_root_endpoint PASSED\ntests/test_api.py::test_health_check PASSED\ntests/test_api.py::test_create_task PASSED\ntests/test_api.py::test_list_tasks PASSED\ntests/test_api.py::test_get_task_by_id PASSED\n... (19 tests au total)\n\n========== 19 passed in 0.45s ==========\n</code></pre>"},{"location":"TP-1/#etape-34-comprendre-un-test","title":"\u00c9tape 3.4 : Comprendre un Test","text":"<p>Regardez <code>test_create_task</code> dans <code>test_api.py</code> :</p> <pre><code>def test_create_task(client):\n    # ARRANGE : Pr\u00e9parer les donn\u00e9es\n    new_task = {\n        \"title\": \"Acheter des courses\",\n        \"description\": \"Lait, \u0153ufs, pain\"\n    }\n\n    # ACT : Faire la requ\u00eate\n    response = client.post(\"/tasks\", json=new_task)\n\n    # ASSERT : V\u00e9rifier\n    assert response.status_code == 201\n    assert response.json()[\"title\"] == \"Acheter des courses\"\n</code></pre> <p>Pattern Arrange-Act-Assert :</p> <ol> <li>Arrange \u2192 Pr\u00e9parer</li> <li>Act \u2192 Agir</li> <li>Assert \u2192 V\u00e9rifier</li> </ol>"},{"location":"TP-1/#phase-4-implementer-les-fonctions-backend","title":"Phase 4 : Impl\u00e9menter les Fonctions Backend","text":""},{"location":"TP-1/#exercice-1-implementer-delete_task","title":"\u270d\ufe0f Exercice 1 : Impl\u00e9menter <code>delete_task()</code>","text":"<p>\ud83c\udfaf Objectif : Compl\u00e9ter la fonction <code>delete_task()</code> dans <code>backend/src/app.py</code></p> <p>Ouvrez <code>backend/src/app.py</code> et trouvez la fonction <code>delete_task()</code> (ligne ~240).</p> <p>Les tests existent d\u00e9j\u00e0 ! Regardez dans <code>test_api.py</code> :</p> <ul> <li><code>test_delete_task</code> : Supprime une t\u00e2che et v\u00e9rifie qu'elle a disparu</li> <li><code>test_delete_nonexistent_task</code> : V\u00e9rifie le 404</li> </ul> <p>Votre mission :</p> <p>Impl\u00e9mentez les 3 \u00e9tapes d\u00e9crites dans le TODO :</p> <pre><code>@app.delete(\"/tasks/{task_id}\", status_code=204)\nasync def delete_task(task_id: int):\n    # TODO: Votre code ici\n    # 1. V\u00e9rifier que la t\u00e2che existe\n    # 2. La supprimer de tasks_db\n    # 3. Retourner None\n</code></pre> <p>V\u00e9rifier votre code :</p> <pre><code>cd backend\nuv run pytest tests/test_api.py::test_delete_task -v\n</code></pre> <p>\u2705 Si le test passe \u2192 Bravo !</p> <p>\u274c Si le test \u00e9choue \u2192 Lisez l'erreur et corrigez</p>"},{"location":"TP-1/#exercice-2-implementer-update_task","title":"\u270d\ufe0f Exercice 2 : Impl\u00e9menter <code>update_task()</code>","text":"<p>\ud83c\udfaf Objectif : Compl\u00e9ter la fonction <code>update_task()</code> dans <code>backend/src/app.py</code></p> <p>Trouvez la fonction <code>update_task()</code> (ligne ~207).</p> <p>Les tests existent d\u00e9j\u00e0 ! Regardez :</p> <ul> <li><code>test_update_task</code> : Change le titre d'une t\u00e2che</li> <li><code>test_update_task_status</code> : Change le statut</li> <li><code>test_update_nonexistent_task</code> : V\u00e9rifie le 404</li> </ul> <p>Votre mission :</p> <p>Impl\u00e9mentez les 7 \u00e9tapes d\u00e9crites dans le TODO.</p> <p>Indices :</p> <ol> <li>C'est similaire \u00e0 <code>create_task</code> mais avec une t\u00e2che existante</li> <li>Utilisez <code>updates.model_dump(exclude_unset=True)</code> pour obtenir les champs fournis</li> <li>Utilisez <code>update_data.get(\"field\", existing_task.field)</code> pour garder les anciennes valeurs si non mises \u00e0 jour</li> </ol> <p>V\u00e9rifier votre code :</p> <pre><code>uv run pytest tests/test_api.py::test_update_task -v\n</code></pre>"},{"location":"TP-1/#exercice-3-ecrire-un-test-de-suppression-inexistante","title":"\u270d\ufe0f Exercice 3 : \u00c9crire un Test de Suppression Inexistante","text":"<p>\ud83c\udfaf Objectif : Tester qu'on ne peut pas supprimer une t\u00e2che qui n'existe pas</p> <p>Ouvrez <code>backend/tests/test_api.py</code> et trouvez la section DELETE TASK TESTS.</p> <p>Ajoutez ce test apr\u00e8s <code>test_delete_task</code> :</p> <pre><code>def test_delete_nonexistent_task_returns_404(client):\n    \"\"\"Deleting a task that doesn't exist should return 404.\"\"\"\n    # TODO: Votre code ici\n    # 1. Essayer de supprimer une t\u00e2che avec un ID qui n'existe pas (ex: 9999)\n    # 2. V\u00e9rifier que \u00e7a retourne 404\n    # 3. V\u00e9rifier le message d'erreur contient \"not found\"\n</code></pre> <p>Indice : C'est un test d'erreur tr\u00e8s simple - seulement 3-4 lignes de code !</p> <p>V\u00e9rifier :</p> <pre><code>uv run pytest tests/test_api.py::test_delete_nonexistent_task_returns_404 -v\n</code></pre>"},{"location":"TP-1/#exercice-4-ecrire-un-test-de-validation","title":"\u270d\ufe0f Exercice 4 : \u00c9crire un Test de Validation","text":"<p>\ud83c\udfaf Objectif : Tester qu'on ne peut pas mettre \u00e0 jour une t\u00e2che avec une priorit\u00e9 invalide</p> <p>Ouvrez <code>backend/tests/test_api.py</code> et trouvez la fonction <code>test_update_task_with_invalid_priority</code>.</p> <p>Votre mission :</p> <p>Impl\u00e9mentez ce test en suivant les \u00e9tapes dans les commentaires :</p> <pre><code>def test_update_task_with_invalid_priority(client):\n    \"\"\"Updating a task with an invalid priority should fail.\"\"\"\n    # TODO: Votre code ici\n    # 1. Cr\u00e9er une t\u00e2che valide\n    # 2. Essayer de la mettre \u00e0 jour avec priority=\"urgent\" (invalide)\n    # 3. V\u00e9rifier que \u00e7a retourne 422 (Erreur de Validation)\n</code></pre> <p>Rappel : Les priorit\u00e9s valides sont <code>\"low\"</code>, <code>\"medium\"</code>, <code>\"high\"</code> (voir <code>TaskPriority</code> dans <code>app.py</code>)</p> <p>V\u00e9rifier :</p> <pre><code>uv run pytest tests/test_api.py::test_update_task_with_invalid_priority -v\n</code></pre>"},{"location":"TP-1/#exercice-5-ecrire-un-test-de-filtrage","title":"\u270d\ufe0f Exercice 5 : \u00c9crire un Test de Filtrage","text":"<p>\ud83c\udfaf Objectif : Tester le filtrage avec plusieurs crit\u00e8res</p> <p>Ajoutez ce test dans la section FILTER TASKS TESTS :</p> <pre><code>def test_filter_by_multiple_criteria(client):\n    \"\"\"Filtering by status AND priority should work.\"\"\"\n    # TODO: Votre code ici\n    # 1. Cr\u00e9er 3 t\u00e2ches avec diff\u00e9rents status et priority\n    # 2. Filtrer avec GET /tasks?status=todo&amp;priority=high\n    # 3. V\u00e9rifier qu'on re\u00e7oit seulement les bonnes t\u00e2ches\n</code></pre> <p>V\u00e9rifier :</p> <pre><code>uv run pytest tests/test_api.py::test_filter_by_multiple_criteria -v\n</code></pre>"},{"location":"TP-1/#etape-46-lancer-tous-les-tests","title":"\u00c9tape 4.6 : Lancer TOUS les Tests","text":"<p>Une fois que vous avez termin\u00e9 les 5 exercices, lancez tous les tests :</p> <pre><code>uv run pytest -v\n</code></pre> <p>R\u00e9sultat attendu :</p> <pre><code>tests/test_api.py::test_root_endpoint PASSED\ntests/test_api.py::test_health_check PASSED\ntests/test_api.py::test_create_simple_task PASSED\n...\ntests/test_api.py::test_delete_task PASSED\ntests/test_api.py::test_update_task PASSED\ntests/test_api.py::test_delete_nonexistent_task_returns_404 PASSED\ntests/test_api.py::test_update_task_with_empty_title PASSED\ntests/test_api.py::test_filter_by_multiple_criteria PASSED\n...\n========== 22+ passed in 0.5s ==========\n</code></pre> <p>\ud83c\udf89 Tous les tests passent ? Vous avez r\u00e9ussi !</p>"},{"location":"TP-1/#phase-5-couverture-de-code","title":"Phase 5 : Couverture de Code","text":""},{"location":"TP-1/#etape-51-lancer-les-tests-avec-couverture","title":"\u00c9tape 5.1 : Lancer les Tests avec Couverture","text":"<pre><code>uv run pytest --cov\n</code></pre> <p>R\u00e9sultat :</p> <pre><code>---------- coverage: platform darwin, python 3.12.7 -----------\nName                Stmts   Miss  Cover\n---------------------------------------\nsrc/app.py            156      6    96%\n---------------------------------------\nTOTAL                 156      6    96%\n</code></pre> <p>Note : La couverture est tr\u00e8s \u00e9lev\u00e9e (96%) car le backend est simple avec stockage en m\u00e9moire. Dans l'TP 3, vous ajouterez une base de donn\u00e9es PostgreSQL.</p> <p></p>"},{"location":"TP-1/#etape-52-generer-un-rapport-html","title":"\u00c9tape 5.2 : G\u00e9n\u00e9rer un Rapport HTML","text":"<pre><code>uv run pytest --cov --cov-report=html\n</code></pre> <p>Ouvrir le rapport :</p> <pre><code>open htmlcov/index.html  # macOS\nstart htmlcov/index.html  # Windows\n</code></pre>"},{"location":"TP-1/#phase-6-tests-frontend","title":"Phase 6 : Tests Frontend","text":""},{"location":"TP-1/#etape-61-comprendre-le-frontend-et-pourquoi-tester","title":"\u00c9tape 6.1 : Comprendre le Frontend et Pourquoi Tester","text":"<p>Le frontend est une application React + TypeScript simple qui communique avec le backend.</p> <p>Structure :</p> <pre><code>frontend/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 App.tsx              # Composant principal\n\u2502   \u251c\u2500\u2500 App.css              # Styles simples\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u251c\u2500\u2500 api.ts           # Client API\n\u2502   \u2502   \u2514\u2500\u2500 api.test.ts      # Tests API \u2190 ON TESTE \u00c7A\n\u2502   \u2514\u2500\u2500 components/\n\u2502       \u251c\u2500\u2500 SimpleTaskList.tsx\n\u2502       \u2514\u2500\u2500 TaskForm.tsx\n\u2514\u2500\u2500 package.json\n</code></pre>"},{"location":"TP-1/#pourquoi-tester-le-frontend","title":"\ud83e\udd14 Pourquoi Tester le Frontend ?","text":"<p>1. V\u00e9rifier la Communication avec le Backend</p> <p>Les tests frontend v\u00e9rifient que votre code JavaScript/TypeScript communique correctement avec l'API backend :</p> <ul> <li>\u2705 Les requ\u00eates HTTP sont-elles correctement form\u00e9es ? (bonne URL, bonne m\u00e9thode, bon format)</li> <li>\u2705 Les donn\u00e9es sont-elles correctement envoy\u00e9es ? (body JSON valide)</li> <li>\u2705 Les r\u00e9ponses sont-elles correctement trait\u00e9es ? (parsing JSON, extraction des donn\u00e9es)</li> <li>\u2705 Les erreurs sont-elles g\u00e9r\u00e9es ? (404, 500, network errors)</li> </ul> <p>2. Tester Sans D\u00e9pendre du Backend</p> <p>Gr\u00e2ce au mocking, on peut tester le frontend m\u00eame si :</p> <ul> <li>\u274c Le backend n'est pas encore d\u00e9velopp\u00e9</li> <li>\u274c Le backend est en panne</li> <li>\u274c On n'a pas de connexion Internet</li> <li>\u274c On veut tester des cas d'erreur difficiles \u00e0 reproduire</li> </ul> <p>Exemple : Comment tester une erreur 500 sans crasher votre vrai backend ? \u2192 Avec un mock !</p> <p>3. Tests Rapides et Fiables</p> <ul> <li>\u26a1 Rapides : Pas besoin de lancer un vrai serveur</li> <li>\ud83d\udd12 Isol\u00e9s : Pas d'effets de bord entre les tests</li> <li>\ud83c\udfaf Pr\u00e9cis : On teste uniquement la logique frontend</li> </ul>"},{"location":"TP-1/#quest-ce-quon-teste","title":"\ud83d\udce6 Qu'est-ce qu'on Teste ?","text":"<p>Dans cet atelier, on teste uniquement le module API (<code>api.ts</code>), pas les composants React.</p> <p>Pourquoi ne pas tester les composants React ?</p> <ul> <li>Les tests de composants React n\u00e9cessitent des outils suppl\u00e9mentaires (React Testing Library)</li> <li>C'est plus complexe (gestion du DOM, \u00e9v\u00e9nements, \u00e9tat)</li> <li>Pour l'TP 1, on se concentre sur les concepts de base des tests</li> </ul> <p>Ce qu'on teste dans <code>api.ts</code> :</p> Fonction Ce qu'elle fait Ce qu'on v\u00e9rifie <code>getTasks()</code> R\u00e9cup\u00e8re la liste des t\u00e2ches Retourne un tableau de t\u00e2ches <code>createTask()</code> Cr\u00e9e une nouvelle t\u00e2che Envoie les bonnes donn\u00e9es en POST <code>deleteTask()</code> Supprime une t\u00e2che Appelle DELETE avec le bon ID <code>updateTask()</code> Met \u00e0 jour une t\u00e2che Envoie PUT avec les modifications"},{"location":"TP-1/#le-concept-de-mocking","title":"\ud83c\udfad Le Concept de Mocking","text":"<p>Probl\u00e8me : Comment tester du code qui appelle une API externe ?</p> <p>Solution : On simule (mock) la fonction <code>fetch()</code> pour qu'elle retourne ce qu'on veut !</p> <pre><code>// Au lieu d'appeler le vrai backend...\nfetch('http://localhost:8000/tasks')\n\n// ...on remplace fetch par une fausse version qui retourne ce qu'on veut\n(globalThis as any).fetch = vi.fn(() =&gt;\n  Promise.resolve({\n    ok: true,\n    json: () =&gt; Promise.resolve([{ id: 1, title: 'Test' }])\n  })\n);\n</code></pre> <p>Avantages :</p> <ul> <li>\u2705 Pas besoin du vrai backend</li> <li>\u2705 Contr\u00f4le total sur les r\u00e9ponses (succ\u00e8s, erreurs, cas limites)</li> <li>\u2705 Tests ultra-rapides</li> </ul>"},{"location":"TP-1/#decorticage-ligne-par-ligne-du-mock","title":"\ud83d\udd2c D\u00e9corticage Ligne par Ligne du Mock","text":"<p>Analysons en d\u00e9tail ce code de mocking qui peut sembler complexe au premier abord :</p> <pre><code>(globalThis as any).fetch = vi.fn(() =&gt;\n  Promise.resolve({\n    ok: true,\n    json: () =&gt; Promise.resolve([\n      { id: 1, title: 'Test Task', status: 'todo' }\n    ]),\n  })\n);\n</code></pre> <p>Ligne 1 : Remplacer la vraie fonction <code>fetch()</code></p> <pre><code>(globalThis as any).fetch = vi.fn(...)\n</code></pre> \u00c9l\u00e9ment Explication <code>globalThis</code> Objet JavaScript global (\u00e9quivalent de <code>window</code> dans le navigateur) <code>.fetch</code> La vraie fonction qui fait les requ\u00eates HTTP <code>vi.fn(...)</code> Cr\u00e9e une fonction \"espion\" (mock) de Vitest <code>(globalThis as any)</code> TypeScript : on force le type pour pouvoir modifier fetch <p>Ce qu'on fait : On remplace la vraie <code>fetch()</code> par une fausse version qu'on contr\u00f4le !</p> <p>Ligne 2 : Simuler une Promesse r\u00e9ussie</p> <pre><code>Promise.resolve({...})\n</code></pre> <ul> <li><code>fetch()</code> retourne toujours une Promise (asynchrone)</li> <li><code>Promise.resolve()</code> simule une promesse qui r\u00e9ussit imm\u00e9diatement</li> <li>On pourrait utiliser <code>Promise.reject()</code> pour simuler une erreur r\u00e9seau</li> </ul> <p>Ligne 3-7 : Simuler la r\u00e9ponse HTTP</p> <pre><code>{\n  ok: true,                    // \u2705 Statut de la r\u00e9ponse\n  json: () =&gt; Promise.resolve([...])  // \ud83d\udce6 Les donn\u00e9es JSON\n}\n</code></pre> Propri\u00e9t\u00e9 Valeur Signification <code>ok</code> <code>true</code> La requ\u00eate HTTP a r\u00e9ussi (status 200-299) <code>ok</code> <code>false</code> La requ\u00eate a \u00e9chou\u00e9 (status 400-599) <code>json()</code> Une fonction qui retourne une Promise Simule <code>response.json()</code> <p>Pourquoi <code>json()</code> est une fonction ?</p> <p>Le vrai <code>fetch()</code> fonctionne comme \u00e7a :</p> <pre><code>const response = await fetch('/tasks');  // \u00c9tape 1 : Obtenir la r\u00e9ponse\nconst data = await response.json();      // \u00c9tape 2 : Parser le JSON\n</code></pre> <p>Notre mock doit imiter exactement ce comportement !</p> <p>Ligne 4-6 : Les donn\u00e9es retourn\u00e9es</p> <pre><code>[\n  { id: 1, title: 'Test Task', status: 'todo' }\n]\n</code></pre> <p>C'est le tableau de t\u00e2ches fictif que notre mock va retourner. On peut mettre ce qu'on veut !</p>"},{"location":"TP-1/#exemples-de-mocks-pour-differents-cas","title":"\ud83c\udfa8 Exemples de Mocks pour Diff\u00e9rents Cas","text":"<p>1\ufe0f\u20e3 Mock pour un Succ\u00e8s (200 OK)</p> <pre><code>(globalThis as any).fetch = vi.fn(() =&gt;\n  Promise.resolve({\n    ok: true,\n    status: 200,\n    json: () =&gt; Promise.resolve({ id: 1, title: 'Ma t\u00e2che' })\n  })\n);\n</code></pre> <p>2\ufe0f\u20e3 Mock pour une Erreur 404 (Not Found)</p> <pre><code>(globalThis as any).fetch = vi.fn(() =&gt;\n  Promise.resolve({\n    ok: false,\n    status: 404,\n    statusText: 'Not Found'\n  })\n);\n</code></pre> <p>3\ufe0f\u20e3 Mock pour une Erreur 500 (Server Error)</p> <pre><code>(globalThis as any).fetch = vi.fn(() =&gt;\n  Promise.resolve({\n    ok: false,\n    status: 500,\n    statusText: 'Server Error'\n  })\n);\n</code></pre> <p>4\ufe0f\u20e3 Mock pour une Erreur R\u00e9seau (pas de connexion)</p> <pre><code>(globalThis as any).fetch = vi.fn(() =&gt;\n  Promise.reject(new Error('Network error'))\n);\n</code></pre>"},{"location":"TP-1/#questions-frequentes-sur-le-mocking","title":"\u2753 Questions Fr\u00e9quentes sur le Mocking","text":"<p>Q : Pourquoi <code>(globalThis as any)</code> ?</p> <p>R : TypeScript prot\u00e8ge <code>globalThis.fetch</code> contre les modifications. <code>as any</code> dit \u00e0 TypeScript \"Fais-moi confiance, je sais ce que je fais !\" C'est normal dans les tests.</p> <p>Q : Pourquoi <code>vi.fn()</code> au lieu d'une fonction normale ?</p> <p>R : <code>vi.fn()</code> cr\u00e9e un spy (espion). On peut ensuite v\u00e9rifier :</p> <pre><code>expect(mockFetch).toHaveBeenCalledWith('/tasks/1', { method: 'DELETE' });\n</code></pre> <p>Avec une fonction normale, on ne pourrait pas faire \u00e7a !</p> <p>Q : Dois-je mocker <code>fetch()</code> dans chaque test ?</p> <p>R : OUI ! Chaque test est isol\u00e9. Si vous ne mocker pas <code>fetch()</code>, le test essaiera d'appeler le vrai backend et \u00e9chouera.</p> <p>Q : Le mock persiste-t-il entre les tests ?</p> <p>R : Non, Vitest r\u00e9initialise les mocks automatiquement entre chaque test. C'est pour garantir l'isolation des tests.</p>"},{"location":"TP-1/#recapitulatif","title":"\ud83c\udfaf R\u00e9capitulatif","text":"Concept Signification Mock Fausse version d'une fonction qu'on contr\u00f4le <code>globalThis.fetch</code> La vraie fonction HTTP qu'on remplace <code>vi.fn()</code> Cr\u00e9e un mock espion (peut \u00eatre v\u00e9rifi\u00e9) <code>Promise.resolve()</code> Simule une promesse qui r\u00e9ussit <code>ok: true</code> Simule un succ\u00e8s HTTP (200-299) <code>json()</code> Fonction qui retourne les donn\u00e9es JSON <p>Important : On teste uniquement l'API (pas les composants React) pour rester simple.</p>"},{"location":"TP-1/#etape-62-installer-les-dependances-frontend","title":"\u00c9tape 6.2 : Installer les D\u00e9pendances Frontend","text":"<pre><code>cd frontend\nnpm install\n</code></pre> <p>Cela va installer toutes les d\u00e9pendances d\u00e9finies dans <code>package.json</code>.</p>"},{"location":"TP-1/#etape-63-lancer-les-tests-frontend","title":"\u00c9tape 6.3 : Lancer les Tests Frontend","text":"<pre><code>npm test\n</code></pre> <p>Vous devriez voir :</p> <pre><code>\u2713 src/api/api.test.ts (3 tests) 4ms\n  \u2713 fetches tasks from the backend\n  \u2713 creates a new task\n  \u2713 throws error when API fails\n\nTest Files  1 passed (1)\n     Tests  3 passed (3)\n</code></pre>"},{"location":"TP-1/#etape-64-analyser-les-tests-en-detail","title":"\u00c9tape 6.4 : Analyser les Tests en D\u00e9tail","text":"<p>Ouvrez <code>frontend/src/api/api.test.ts</code> et analysons ligne par ligne comment fonctionne un test :</p> <pre><code>describe('API Module', () =&gt; {\n  it('fetches tasks from the backend', async () =&gt; {\n    // \u00c9TAPE 1 : Mock fetch pour simuler la r\u00e9ponse du backend\n    (globalThis as any).fetch = vi.fn(() =&gt;\n      Promise.resolve({\n        ok: true,\n        json: () =&gt; Promise.resolve([\n          { id: 1, title: 'Test Task', status: 'todo' }\n        ]),\n      })\n    );\n\n    // \u00c9TAPE 2 : Appeler la fonction \u00e0 tester\n    const tasks = await api.getTasks();\n\n    // \u00c9TAPE 3 : V\u00e9rifier les r\u00e9sultats\n    expect(tasks).toHaveLength(1);\n    expect(tasks[0].title).toBe('Test Task');\n  });\n});\n</code></pre>"},{"location":"TP-1/#explication-detaillee","title":"\ud83d\udd0d Explication D\u00e9taill\u00e9e","text":"<p>\u00c9TAPE 1 : Pourquoi mocker <code>fetch()</code> ?</p> <pre><code>(globalThis as any).fetch = vi.fn(() =&gt; ...)\n</code></pre> <ul> <li><code>globalThis.fetch</code> = la fonction JavaScript qui fait les requ\u00eates HTTP</li> <li><code>vi.fn()</code> = remplace fetch par une fausse version (mock) de Vitest</li> <li>On contr\u00f4le ce qu'elle retourne \u2192 pas d'appel r\u00e9seau r\u00e9el</li> </ul> <p>Ce que le mock retourne :</p> <pre><code>Promise.resolve({\n  ok: true,                    // \u2705 Requ\u00eate r\u00e9ussie (pas d'erreur)\n  json: () =&gt; Promise.resolve([...])  // Les donn\u00e9es JSON \u00e0 retourner\n})\n</code></pre> <p>C'est exactement ce que le vrai <code>fetch()</code> retournerait, mais sans r\u00e9seau !</p> <p>\u00c9TAPE 2 : Appeler la fonction</p> <pre><code>const tasks = await api.getTasks();\n</code></pre> <ul> <li>Appelle la vraie fonction <code>getTasks()</code> de notre API</li> <li>Cette fonction utilise <code>fetch()</code> en interne</li> <li>Mais <code>fetch()</code> est maintenant notre mock \u2192 retourne instantan\u00e9ment les donn\u00e9es fictives</li> </ul> <p>\u00c9TAPE 3 : V\u00e9rifier les r\u00e9sultats</p> <pre><code>expect(tasks).toHaveLength(1);       // \u2705 On a bien re\u00e7u 1 t\u00e2che\nexpect(tasks[0].title).toBe('Test Task');  // \u2705 Le titre est correct\n</code></pre>"},{"location":"TP-1/#comparaison-backend-vs-frontend","title":"\ud83d\udcca Comparaison Backend vs Frontend","text":"Aspect Tests Backend (pytest) Tests Frontend (Vitest) Framework pytest Vitest Langage Python TypeScript Assertions <code>assert response.status_code == 200</code> <code>expect(response.ok).toBe(true)</code> Mocking Fixtures (<code>client</code>) <code>vi.fn()</code> Asynchrone Pas n\u00e9cessaire (FastAPI le g\u00e8re) <code>async/await</code> obligatoire Pattern Arrange-Act-Assert Arrange-Act-Assert (identique!) <p>La bonne nouvelle : Les concepts sont identiques entre backend et frontend !</p>"},{"location":"TP-1/#les-5-tests-expliques","title":"\ud83c\udfaf Les 5 Tests Expliqu\u00e9s","text":"Test Objectif Ce qu'on v\u00e9rifie Test 1 : <code>fetches tasks</code> R\u00e9cup\u00e9rer des t\u00e2ches \u2705 Re\u00e7oit un tableau avec les bonnes donn\u00e9es Test 2 : <code>creates a new task</code> Cr\u00e9er une t\u00e2che \u2705 Envoie POST avec les bonnes donn\u00e9es Test 3 : <code>throws error when API fails</code> Gestion d'erreur \u2705 L\u00e8ve une exception si le backend r\u00e9pond 500 Test 4 : <code>deletes a task</code> Supprimer une t\u00e2che \u2705 Appelle DELETE avec le bon ID Test 5 : <code>updates a task</code> Mettre \u00e0 jour une t\u00e2che \u2705 Envoie PUT avec les modifications <p>Pourquoi ces tests sont importants ?</p> <ul> <li>\ud83d\udc1b D\u00e9tecter les bugs : Si on change l'URL de l'API, les tests \u00e9chouent</li> <li>\ud83d\udd12 Garantir la qualit\u00e9 : Les nouvelles fonctionnalit\u00e9s ne cassent pas l'existant</li> <li>\ud83d\udcd6 Documentation vivante : Les tests montrent comment utiliser l'API</li> </ul>"},{"location":"TP-1/#etape-65-couverture-frontend","title":"\u00c9tape 6.5 : Couverture Frontend","text":"<pre><code>npm run test:coverage\n</code></pre> <p>R\u00e9sultat :</p> <pre><code>File       | % Stmts | % Branch | % Funcs | % Lines |\n-----------|---------|----------|---------|---------|\napi.ts     |   68.42 |    55.55 |      50 |   68.42 |\n</code></pre> <p>Note : On teste uniquement l'API (pas les composants React).</p>"},{"location":"TP-1/#etape-66-comprendre-un-test-existant","title":"\u00c9tape 6.6 : Comprendre un Test Existant","text":"<p>Avant d'\u00e9crire votre test, analysons comment fonctionne le test <code>creates a new task</code> :</p> <pre><code>it('creates a new task', async () =&gt; {\n  // 1. ARRANGE : Pr\u00e9parer les donn\u00e9es\n  const newTask = { title: 'New Task', status: 'todo' as const };\n\n  // 2. ARRANGE : Mocker fetch pour simuler la r\u00e9ponse du backend\n  (globalThis as any).fetch = vi.fn(() =&gt;\n    Promise.resolve({\n      ok: true,\n      json: () =&gt; Promise.resolve({ ...newTask, id: 1 }),\n    })\n  );\n\n  // 3. ACT : Appeler la fonction \u00e0 tester\n  const created = await api.createTask(newTask);\n\n  // 4. ASSERT : V\u00e9rifier les r\u00e9sultats\n  expect(created.id).toBe(1);\n  expect(created.title).toBe('New Task');\n});\n</code></pre> <p>Que fait ce test ?</p> <ol> <li>Arrange : Pr\u00e9pare les donn\u00e9es (newTask) et mock fetch</li> <li>Act : Appelle <code>api.createTask()</code></li> <li>Assert : V\u00e9rifie que la t\u00e2che cr\u00e9\u00e9e a bien un ID et le bon titre</li> </ol> <p>Pattern AAA - le m\u00eame qu'en Python ! \ud83c\udfaf</p>"},{"location":"TP-1/#exercice-6-ecrire-un-test-frontend-10-min","title":"\u270d\ufe0f Exercice 6 : \u00c9crire un Test Frontend (10 min)","text":"<p>\ud83c\udfaf Objectif : Tester la fonction <code>deleteTask()</code> du module API</p> <p>Ouvrez <code>frontend/src/api/api.test.ts</code> et trouvez le test marqu\u00e9 <code>it.todo(...)</code> :</p> <pre><code>it.todo('deletes a task', async () =&gt; {\n  // TODO: Votre code ici\n  // 1. Mocker fetch pour simuler une suppression r\u00e9ussie (status: 204)\n  // 2. Appeler await api.deleteTask(1)\n  // 3. V\u00e9rifier que fetch a \u00e9t\u00e9 appel\u00e9 avec la bonne URL et m\u00e9thode DELETE\n});\n</code></pre> <p>Votre mission : Impl\u00e9mentez ce test en suivant les 3 \u00e9tapes !</p> <p>Indice : Regardez le test <code>creates a new task</code> juste au-dessus pour vous inspirer.</p> <p>V\u00e9rifier votre test :</p> <pre><code>cd frontend\nnpm test\n</code></pre> <p>\u2705 Si le test passe \u2192 Bravo ! Vous devriez voir 4 tests passed au lieu de 3 !</p> <p>\u274c Si le test \u00e9choue \u2192 Lisez l'erreur et corrigez</p>"},{"location":"TP-1/#exercice-7-ecrire-un-test-update-frontend-10-min","title":"\u270d\ufe0f Exercice 7 : \u00c9crire un Test UPDATE Frontend (10 min)","text":"<p>\ud83c\udfaf Objectif : Tester la fonction <code>updateTask()</code> du module API</p> <p>Dans <code>frontend/src/api/api.test.ts</code>, trouvez le deuxi\u00e8me test marqu\u00e9 <code>it.todo(...)</code> :</p> <pre><code>it.todo('updates a task', async () =&gt; {\n  // TODO: Votre code ici\n  // 1. Mocker fetch pour simuler une mise \u00e0 jour r\u00e9ussie\n  // 2. Appeler await api.updateTask(1, { title: 'Updated Title' })\n  // 3. V\u00e9rifier que fetch a \u00e9t\u00e9 appel\u00e9 avec la bonne URL, m\u00e9thode PUT et body\n});\n</code></pre> <p>Votre mission : Impl\u00e9mentez ce test en suivant les 3 \u00e9tapes !</p> <p>Indices :</p> <ol> <li>C'est similaire au test DELETE, mais avec m\u00e9thode <code>PUT</code> au lieu de <code>DELETE</code></li> <li>Il faut aussi v\u00e9rifier le <code>body</code> contient les bonnes donn\u00e9es</li> <li>Le mock fetch doit retourner un objet avec <code>json()</code> (comme dans <code>creates a new task</code>)</li> </ol> <p>V\u00e9rifier votre test :</p> <pre><code>npm test\n</code></pre> <p>\u2705 Si le test passe \u2192 Bravo ! Vous devriez voir 5 tests passed !</p> <p>\u274c Si le test \u00e9choue \u2192 Lisez l'erreur et corrigez</p>"},{"location":"TP-1/#etape-67-verifier-la-couverture","title":"\u00c9tape 6.7 : V\u00e9rifier la Couverture","text":"<pre><code>npm run test:coverage\n</code></pre> <p>R\u00e9sultat :</p> <pre><code>File       | % Stmts | % Branch | % Funcs | % Lines |\n-----------|---------|----------|---------|---------|\napi.ts     |   84.21 |    66.67 |   71.43 |   84.21 |\n</code></pre> <p>La couverture a augment\u00e9 gr\u00e2ce \u00e0 vos tests ! \ud83c\udf89</p>"},{"location":"TP-1/#etape-68-lancer-lapplication-complete","title":"\u00c9tape 6.8 : Lancer l'Application Compl\u00e8te","text":"<p>Terminal 1 - Backend :</p> <pre><code>cd backend\nuv run uvicorn src.app:app --reload\n</code></pre> <p>Terminal 2 - Frontend :</p> <pre><code>cd frontend\nnpm install  # Si pas d\u00e9j\u00e0 fait\nnpm run dev\n</code></pre> <p>Ouvrir dans le navigateur : http://localhost:5173</p> <p>Vous devriez voir l'application TaskFlow fonctionner :</p> <p></p>"},{"location":"TP-1/#exercices-bonus-java-avec-junit","title":"\ud83c\udf81 Exercices Bonus : Java avec JUnit","text":"<p>Objectif : Voir que les principes de TDD s'appliquent \u00e0 tous les langages !</p> <p>Les exercices Java sont dans le dossier <code>java-exercises/</code>.</p>"},{"location":"TP-1/#prerequis-installer-java","title":"Pr\u00e9requis : Installer Java","text":"<pre><code># V\u00e9rifier si d\u00e9j\u00e0 install\u00e9\njava -version    # Devrait afficher Java 17+\n</code></pre> <p>Si pas install\u00e9 :</p> <ul> <li>macOS : <code>brew install openjdk@17</code></li> <li>Linux : <code>sudo apt install openjdk-17-jdk</code></li> <li>Windows : Installer depuis adoptium.net</li> </ul> <p>Commandes de base :</p> <p>Chaque exercice utilise un Makefile pour simplifier la compilation et l'ex\u00e9cution :</p> <pre><code>make test     # Compiler + Ex\u00e9cuter les tests + Nettoyer\nmake compile  # Compiler uniquement\nmake clean    # Supprimer les fichiers .class\n</code></pre>"},{"location":"TP-1/#exercice-1-calculs-geometriques-composition-de-fonctions","title":"\u270d\ufe0f Exercice 1 : Calculs G\u00e9om\u00e9triques (Composition de Fonctions)","text":"<p>\ud83c\udfaf Objectif : Impl\u00e9menter des op\u00e9rations math\u00e9matiques en composant des fonctions simples</p> <p>Ouvrez le dossier <code>edl-starter/java-exercises/calculs-geo/</code></p> <p>Fichiers du projet :</p> <ul> <li><code>Addition.java</code> : Classe d'exemple d\u00e9j\u00e0 impl\u00e9ment\u00e9e</li> <li><code>Produit.java</code> : \u00c0 compl\u00e9ter (multiplication)</li> <li><code>Surface.java</code> : \u00c0 compl\u00e9ter (surface rectangle)</li> <li><code>Perimetre.java</code> : \u00c0 compl\u00e9ter (p\u00e9rim\u00e8tre)</li> <li>Tests : <code>AdditionTest.java</code>, <code>ProduitTest.java</code>, <code>SurfaceTest.java</code>, <code>PerimetreTest.java</code></li> </ul> <p>Votre mission - Partie 1 : Impl\u00e9menter <code>Produit.mult()</code></p> <p>Ouvrez <code>Produit.java</code> et compl\u00e9tez la m\u00e9thode :</p> <pre><code>public class Produit {\n    public static int mult(int a, int b) {\n        // TODO: Retourner le produit de a et b\n        return 0;\n    }\n}\n</code></pre> <p>Test correspondant (<code>ProduitTest.java</code>) :</p> <pre><code>@Test\npublic void testMult() {\n    assertEquals(6, Produit.mult(2, 3));\n    assertEquals(0, Produit.mult(0, 5));\n    assertEquals(-6, Produit.mult(-2, 3));\n}\n</code></pre> <p>Indice : Utilisez l'op\u00e9rateur <code>*</code> pour multiplier deux nombres.</p> <p>V\u00e9rifier votre code :</p> <pre><code>cd edl-starter/java-exercises/calculs-geo\nmake test\n</code></pre> <p>R\u00e9sultat attendu apr\u00e8s impl\u00e9mentation :</p> <pre><code>JUnit version 4.13.2\n..E.E\nTime: 0.006\nThere were 2 failures:\n...\nTests run: 4,  Failures: 2\n</code></pre> <p>Le test <code>ProduitTest</code> devrait maintenant passer !</p> <p>Votre mission - Partie 2 : Impl\u00e9menter <code>Surface.surf()</code></p> <p>Ouvrez <code>Surface.java</code> et compl\u00e9tez la m\u00e9thode :</p> <pre><code>public class Surface {\n    public static int surf(int a, int b) {\n        // TODO: Utiliser Produit.mult() pour calculer la surface d'un rectangle\n        return 0;\n    }\n}\n</code></pre> <p>Test correspondant (<code>SurfaceTest.java</code>) :</p> <pre><code>@Test\npublic void testSurf() {\n    assertEquals(6, Surface.surf(2, 3));\n    assertEquals(0, Surface.surf(0, 5));\n    assertEquals(12, Surface.surf(3, 4));\n}\n</code></pre> <p>Indice : La surface d'un rectangle = longueur \u00d7 largeur. R\u00e9utilisez la fonction <code>Produit.mult()</code> que vous venez d'\u00e9crire.</p> <p>Exemple de solution :</p> <pre><code>return Produit.mult(a, b);\n</code></pre> <p>V\u00e9rifier :</p> <pre><code>make test\n</code></pre> <p>Maintenant 2 tests sur 4 devraient passer.</p> <p>Votre mission - Partie 3 : Impl\u00e9menter <code>Perimetre.perim()</code></p> <p>Ouvrez <code>Perimetre.java</code> et compl\u00e9tez la m\u00e9thode :</p> <pre><code>public class Perimetre {\n    public static int perim(int a, int b, int c) {\n        // TODO: Calculer (a+b)*c en utilisant Addition.add() et Produit.mult()\n        return 0;\n    }\n}\n</code></pre> <p>Test correspondant (<code>PerimetreTest.java</code>) :</p> <pre><code>@Test\npublic void testPerim() {\n    assertEquals(10, Perimetre.perim(2, 3, 2));  // (2+3)*2 = 10\n    assertEquals(0, Perimetre.perim(0, 0, 5));\n    assertEquals(14, Perimetre.perim(3, 4, 2));  // (3+4)*2 = 14\n}\n</code></pre> <p>Indice :</p> <ol> <li>Commencez par additionner <code>a</code> et <code>b</code> avec <code>Addition.add(a, b)</code></li> <li>Multipliez le r\u00e9sultat par <code>c</code> avec <code>Produit.mult()</code></li> </ol> <p>Exemple de solution :</p> <pre><code>int somme = Addition.add(a, b);\nreturn Produit.mult(somme, c);\n</code></pre> <p>V\u00e9rifier :</p> <pre><code>make test\n</code></pre> <p>R\u00e9sultat final attendu :</p> <pre><code>JUnit version 4.13.2\n....\nTime: 0.006\n\nOK (4 tests)\n</code></pre> <p>Tous les tests passent ? Bravo ! Passez \u00e0 l'exercice suivant.</p>"},{"location":"TP-1/#exercice-2-money-addition-avec-validation-de-devises","title":"\u270d\ufe0f Exercice 2 : Money - Addition avec Validation de Devises","text":"<p>\ud83c\udfaf Objectif : Impl\u00e9menter une m\u00e9thode d'addition qui valide que deux montants ont la m\u00eame devise</p> <p>Ouvrez le dossier <code>edl-starter/java-exercises/money/</code></p> <p>Fichiers du projet :</p> <ul> <li><code>Money.java</code> : Classe avec m\u00e9thode <code>add()</code> \u00e0 impl\u00e9menter</li> <li><code>MoneyTest.java</code> : Tests JUnit (certains avec TODOs \u00e0 compl\u00e9ter)</li> </ul> <p>Votre mission :</p> <p>Ouvrez <code>Money.java</code> et impl\u00e9mentez la m\u00e9thode <code>add()</code> :</p> <pre><code>public Money add(Money m) throws Exception {\n    // TODO: V\u00e9rifier si this.currency().equals(m.currency())\n    // TODO: Si oui, retourner new Money(this.amount() + m.amount(), this.currency())\n    // TODO: Si non, throw new Exception(\"Not Same currency\")\n    return null;\n}\n</code></pre> <p>R\u00e8gles m\u00e9tier :</p> <ul> <li>On peut additionner deux montants de m\u00eame devise : <code>12 EUR + 5 EUR = 17 EUR</code></li> <li>On ne peut PAS additionner deux montants de devises diff\u00e9rentes : <code>12 EUR + 5 USD</code> \u2192 Exception</li> </ul> <p>Tests correspondants (<code>MoneyTest.java</code>) :</p> <pre><code>@Test\npublic void testSimpleAdd() throws Exception {\n    Money m12EUR = new Money(12, \"EUR\");\n    Money m14EUR = new Money(14, \"EUR\");\n    Money expected = new Money(26, \"EUR\");\n    assertEquals(expected, m12EUR.add(m14EUR));\n}\n\n@Test(expected = Exception.class)\npublic void testAddDifferentCurrency() throws Exception {\n    Money m12EUR = new Money(12, \"EUR\");\n    Money m5USD = new Money(5, \"USD\");\n    m12EUR.add(m5USD);  // Doit lever une exception\n}\n</code></pre> <p>Indices :</p> <ol> <li>Utilisez <code>this.currency()</code> pour obtenir la devise de l'objet courant</li> <li>Utilisez <code>m.currency()</code> pour obtenir la devise du param\u00e8tre</li> <li>Comparez avec <code>.equals()</code> (pas <code>==</code>)</li> <li>Si les devises sont identiques, cr\u00e9ez un nouveau <code>Money</code> avec la somme des montants</li> <li>Si les devises sont diff\u00e9rentes, lancez une exception avec <code>throw new Exception(\"Not Same currency\")</code></li> </ol> <p>Exemple de solution :</p> <pre><code>public Money add(Money m) throws Exception {\n    if (this.currency().equals(m.currency())) {\n        return new Money(this.amount() + m.amount(), this.currency());\n    }\n    throw new Exception(\"Not Same currency\");\n}\n</code></pre> <p>V\u00e9rifier votre code :</p> <pre><code>cd edl-starter/java-exercises/money\nmake test\n</code></pre> <p>R\u00e9sultat attendu :</p> <pre><code>JUnit version 4.13.2\n....\nTime: 0.007\n\nOK (4 tests)\n</code></pre> <p>Tous les tests passent ? F\u00e9licitations !</p>"},{"location":"TP-1/#comprendre-junit-4-les-bases","title":"\ud83d\udcda Comprendre JUnit 4 - Les Bases","text":"<p>Structure d'un test JUnit :</p> <pre><code>import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ExampleTest {\n\n    @Test\n    public void testMethodName() {\n        // Arrange : Pr\u00e9parer les donn\u00e9es\n        int a = 2;\n        int b = 3;\n\n        // Act : Ex\u00e9cuter la m\u00e9thode \u00e0 tester\n        int result = MyClass.add(a, b);\n\n        // Assert : V\u00e9rifier le r\u00e9sultat\n        assertEquals(5, result);\n    }\n}\n</code></pre> <p>Annotations JUnit :</p> <ul> <li><code>@Test</code> : Indique qu'une m\u00e9thode est un test</li> <li><code>@Test(expected = Exception.class)</code> : Le test passe si l'exception est lev\u00e9e</li> </ul> <p>M\u00e9thodes d'assertion principales :</p> <pre><code>assertEquals(expected, actual);     // V\u00e9rifie que deux valeurs sont \u00e9gales\nassertTrue(condition);              // V\u00e9rifie qu'une condition est vraie\nassertFalse(condition);             // V\u00e9rifie qu'une condition est fausse\nassertNull(object);                 // V\u00e9rifie qu'un objet est null\nassertNotNull(object);              // V\u00e9rifie qu'un objet n'est pas null\n</code></pre> <p>Exemple de test d'exception :</p> <pre><code>@Test(expected = Exception.class)\npublic void testInvalidOperation() throws Exception {\n    Money m1 = new Money(12, \"EUR\");\n    Money m2 = new Money(5, \"USD\");\n    m1.add(m2);  // Cette ligne doit lever une Exception\n}\n</code></pre>"},{"location":"TP-2/","title":"\ud83d\ude80 TP 2 : CI/CD avec GitHub Actions","text":"<p>Pr\u00e9requis : TP 1 termin\u00e9 (backend et frontend avec tests)</p>"},{"location":"TP-2/#objectifs-de-latelier","title":"\ud83c\udfaf Objectifs de l'Atelier","text":"<p>Objectif principal : Automatiser les tests avec GitHub Actions</p> <p>\u00c0 la fin de cet atelier, vous aurez :</p> <ol> <li>\u2705 Cr\u00e9\u00e9 un workflow backend qui teste automatiquement votre code Python</li> <li>\u2705 Cr\u00e9\u00e9 un workflow frontend qui teste et build votre code TypeScript</li> <li>\u2705 Compris comment d\u00e9boguer un workflow qui \u00e9choue</li> <li>\u2705 Optimis\u00e9 vos workflows avec le cache</li> <li>\u2705 Cr\u00e9\u00e9 des workflows r\u00e9utilisables et des pipelines CI</li> <li>\u2705 S\u00e9par\u00e9 les tests rapides (unitaires) des tests lents (E2E)</li> <li>\u2705 Ajout\u00e9 des badges de status \u00e0 votre README</li> </ol>"},{"location":"TP-2/#quest-ce-que-cicd","title":"\ud83d\udce6 Qu'est-ce que CI/CD ?","text":"<p>CI (Continuous Integration) :</p> <ul> <li>Int\u00e9gration Continue</li> <li>\u00c0 chaque push, les tests s'ex\u00e9cutent automatiquement</li> <li>D\u00e9tecte les bugs imm\u00e9diatement</li> </ul> <p>CD (Continuous Deployment) :</p> <ul> <li>D\u00e9ploiement Continu (TP 3)</li> <li>Si les tests passent, d\u00e9ploiement automatique</li> </ul> <p>GitHub Actions :</p> <ul> <li>Service gratuit de GitHub</li> <li>Ex\u00e9cute vos tests sur des serveurs GitHub</li> <li>V\u00e9rifie chaque commit et pull request</li> </ul>"},{"location":"TP-2/#structure-dun-workflow-github-actions","title":"\ud83d\udcda Structure d'un Workflow GitHub Actions","text":"<p>Un workflow GitHub Actions est un fichier YAML dans <code>.github/workflows/</code>.</p> <p>Structure de base :</p> <pre><code>name: Mon Workflow          # 1\ufe0f\u20e3 Nom affich\u00e9 dans GitHub\n\non:                         # 2\ufe0f\u20e3 Quand s'ex\u00e9cute-t-il ?\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:                       # 3\ufe0f\u20e3 Les t\u00e2ches \u00e0 faire\n  test:\n    runs-on: ubuntu-latest  # 4\ufe0f\u20e3 Machine virtuelle\n    steps:                  # 5\ufe0f\u20e3 Les \u00e9tapes\n      - uses: actions/checkout@v4\n      - run: pytest\n</code></pre> <p>Concepts cl\u00e9s :</p> <ul> <li><code>name</code> : Nom du workflow</li> <li><code>on</code> : D\u00e9clencheurs (push, pull_request, etc.)</li> <li><code>jobs</code> : T\u00e2ches parall\u00e8les</li> <li><code>steps</code> : \u00c9tapes s\u00e9quentielles</li> <li><code>uses</code> : Action pr\u00e9-faite</li> <li><code>run</code> : Commande shell</li> </ul>"},{"location":"TP-2/#exercice-1-workflow-backend","title":"\u270d\ufe0f Exercice 1 : Workflow Backend","text":""},{"location":"TP-2/#objectif","title":"Objectif","text":"<p>Cr\u00e9er un workflow qui teste automatiquement le backend \u00e0 chaque push.</p>"},{"location":"TP-2/#instructions","title":"Instructions","text":"<ol> <li>Cr\u00e9ez la structure des workflows :</li> </ol> <pre><code>mkdir -p .github/workflows\n</code></pre> <ol> <li> <p>Cr\u00e9ez le fichier <code>.github/workflows/backend.yml</code></p> </li> <li> <p>Configurez le workflow avec :</p> </li> <li>Nom : \"Backend Tests\"</li> <li>D\u00e9clencheurs : push et pull_request sur <code>main</code></li> <li> <p>Job nomm\u00e9 \"test\" qui s'ex\u00e9cute sur <code>ubuntu-latest</code></p> </li> <li> <p>Ajoutez les \u00e9tapes suivantes (dans l'ordre) :</p> </li> <li>R\u00e9cup\u00e9rer le code avec <code>actions/checkout@v4</code></li> <li>Installer Python 3.11 avec <code>actions/setup-python@v5</code></li> <li> <p>Installer UV :</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\necho \"$HOME/.cargo/bin\" &gt;&gt; $GITHUB_PATH\n</code></pre> </li> <li> <p>Installer les d\u00e9pendances : <code>cd backend &amp;&amp; uv sync</code></p> </li> <li> <p>Lancer les tests : <code>cd backend &amp;&amp; uv run pytest -v --cov</code></p> </li> <li> <p>Testez localement avant de pousser :</p> </li> </ol> <pre><code>cd backend\nuv run pytest -v --cov\n</code></pre> <ol> <li>Poussez et v\u00e9rifiez sur GitHub Actions :</li> </ol> <pre><code>git add .github/workflows/backend.yml\ngit commit -m \"ci: add backend workflow\"\ngit push origin main\n</code></pre>"},{"location":"TP-2/#resultat-attendu","title":"\u2705 R\u00e9sultat attendu","text":"<p>Dans l'onglet \"Actions\" sur GitHub, vous devriez voir :</p> <pre><code>\u2705 Backend Tests\n  \u2514\u2500 test\n      \u251c\u2500 Checkout code\n      \u251c\u2500 Setup Python\n      \u251c\u2500 Install UV\n      \u251c\u2500 Install dependencies\n      \u2514\u2500 Run tests\n</code></pre>"},{"location":"TP-2/#exercice-2-workflow-frontend","title":"\u270d\ufe0f Exercice 2 : Workflow Frontend","text":""},{"location":"TP-2/#objectif_1","title":"Objectif","text":"<p>Cr\u00e9er un workflow qui teste et build le frontend automatiquement.</p>"},{"location":"TP-2/#instructions_1","title":"Instructions","text":"<ol> <li> <p>Cr\u00e9ez le fichier <code>.github/workflows/frontend.yml</code></p> </li> <li> <p>Configurez le workflow similairement au backend :</p> </li> <li>Nom : \"Frontend Tests\"</li> <li> <p>M\u00eames d\u00e9clencheurs que le backend</p> </li> <li> <p>Ajoutez les \u00e9tapes suivantes :</p> </li> <li>R\u00e9cup\u00e9rer le code</li> <li>Installer Node.js 18 avec <code>actions/setup-node@v4</code><ul> <li>Activez le cache npm : <code>cache: 'npm'</code></li> <li>Sp\u00e9cifiez le chemin : <code>cache-dependency-path: frontend/package-lock.json</code></li> </ul> </li> <li>Installer les d\u00e9pendances : <code>cd frontend &amp;&amp; npm ci</code></li> <li>Lancer les tests : <code>cd frontend &amp;&amp; npm test -- --run</code></li> <li> <p>V\u00e9rifier le build : <code>cd frontend &amp;&amp; npm run build</code></p> </li> <li> <p>Testez localement :</p> </li> </ol> <pre><code>cd frontend\nnpm test -- --run\nnpm run build\n</code></pre> <ol> <li>Poussez et v\u00e9rifiez :</li> </ol> <pre><code>git add .github/workflows/frontend.yml\ngit commit -m \"ci: add frontend workflow\"\ngit push origin main\n</code></pre>"},{"location":"TP-2/#resultat-attendu_1","title":"\u2705 R\u00e9sultat attendu","text":"<p>Vous devriez voir 2 workflows en parall\u00e8le :</p> <pre><code>\u2705 Backend Tests\n\u2705 Frontend Tests\n</code></pre>"},{"location":"TP-2/#note-importante","title":"\ud83d\udca1 Note importante","text":"<p><code>npm ci</code> vs <code>npm install</code> :</p> <ul> <li><code>npm ci</code> : Installe exactement ce qui est dans <code>package-lock.json</code> (d\u00e9terministe)</li> <li><code>npm install</code> : Peut mettre \u00e0 jour les versions (moins fiable pour CI)</li> </ul>"},{"location":"TP-2/#exercice-3-deboguer-un-echec","title":"\u270d\ufe0f Exercice 3 : D\u00e9boguer un \u00c9chec","text":""},{"location":"TP-2/#objectif_2","title":"Objectif","text":"<p>Apprendre \u00e0 lire les logs et corriger les erreurs de workflow.</p>"},{"location":"TP-2/#instructions_2","title":"Instructions","text":"<ol> <li>Introduisez volontairement un bug dans <code>backend/tests/test_api.py</code> :</li> </ol> <pre><code>def test_health_check(client):\n    response = client.get(\"/health\")\n    assert response.status_code == 200\n    assert response.json()[\"status\"] == \"BROKEN\"  # \u274c Faux expr\u00e8s !\n</code></pre> <ol> <li>Poussez le bug :</li> </ol> <pre><code>git add backend/tests/test_api.py\ngit commit -m \"test: intentional failure for learning\"\ngit push origin main\n</code></pre> <ol> <li>Observez l'\u00e9chec sur GitHub Actions :</li> <li>Allez dans \"Actions\"</li> <li>Cliquez sur le workflow \u274c rouge</li> <li> <p>Cliquez sur l'\u00e9tape \"Run tests\"</p> </li> <li> <p>Analysez les logs :</p> </li> <li>Quel test \u00e9choue ?</li> <li>\u00c0 quelle ligne ?</li> <li> <p>Quelle est l'erreur exacte ?</p> </li> <li> <p>Reproduisez localement :</p> </li> </ol> <pre><code>cd backend\nuv run pytest tests/test_api.py::test_health_check -v\n</code></pre> <ol> <li>Corrigez le bug :</li> </ol> <pre><code>assert response.json()[\"status\"] == \"healthy\"  # \u2705 Correct\n</code></pre> <ol> <li>V\u00e9rifiez localement puis poussez :</li> </ol> <pre><code>uv run pytest tests/test_api.py::test_health_check -v\ngit add backend/tests/test_api.py\ngit commit -m \"fix: correct health check assertion\"\ngit push origin main\n</code></pre>"},{"location":"TP-2/#lecon-apprise","title":"\u2705 Le\u00e7on apprise","text":"<p>Si \u00e7a passe localement, \u00e7a passera sur GitHub !</p>"},{"location":"TP-2/#exercice-4-optimiser-avec-le-cache","title":"\u270d\ufe0f Exercice 4 : Optimiser avec le Cache","text":""},{"location":"TP-2/#objectif_3","title":"Objectif","text":"<p>R\u00e9duire le temps d'ex\u00e9cution de 2-3 minutes \u00e0 ~30 secondes en utilisant le cache.</p>"},{"location":"TP-2/#instructions_3","title":"Instructions","text":"<ol> <li> <p>Modifiez <code>.github/workflows/backend.yml</code></p> </li> <li> <p>Ajoutez une \u00e9tape de cache APR\u00c8S l'installation de Python :</p> </li> </ol> <pre><code>- name: \ud83d\udcbe Cache UV dependencies\n  uses: actions/cache@v4\n  with:\n    path: ~/.cache/uv\n    key: ${{ runner.os }}-uv-${{ hashFiles('backend/pyproject.toml', 'backend/uv.lock') }}\n    restore-keys: |\n      ${{ runner.os }}-uv-\n</code></pre> <ol> <li>Comprenez la cl\u00e9 du cache :</li> <li><code>${{ runner.os }}</code> : OS (Linux)</li> <li><code>${{ hashFiles(...) }}</code> : Hash des fichiers de d\u00e9pendances</li> <li> <p>Le cache change seulement si vous ajoutez/retirez une d\u00e9pendance</p> </li> <li> <p>Testez en poussant deux fois :</p> </li> </ol> <pre><code># Premier push - cache vide\ngit add .github/workflows/backend.yml\ngit commit -m \"ci: add UV cache\"\ngit push\n\n# Deuxi\u00e8me push - cache restaur\u00e9\necho \"# Test cache\" &gt;&gt; README.md\ngit add README.md\ngit commit -m \"test: trigger workflow\"\ngit push\n</code></pre> <ol> <li>Observez la diff\u00e9rence :</li> <li>1\u00e8re ex\u00e9cution : \"Cache not found\" \u2192 t\u00e9l\u00e9charge tout (~2 min)</li> <li>2\u00e8me ex\u00e9cution : \"Cache restored\" \u2192 utilise le cache (~30 sec)</li> </ol>"},{"location":"TP-2/#resultat","title":"\u2705 R\u00e9sultat","text":"<p>Temps gagn\u00e9 : ~2 minutes par build ! \u26a1</p>"},{"location":"TP-2/#exercice-5-workflows-reutilisables","title":"\u270d\ufe0f Exercice 5 : Workflows R\u00e9utilisables","text":""},{"location":"TP-2/#objectif_4","title":"Objectif","text":"<p>Cr\u00e9er un pipeline CI global qui orchestre backend et frontend.</p>"},{"location":"TP-2/#instructions_4","title":"Instructions","text":"<ol> <li>Rendez vos workflows r\u00e9utilisables :</li> </ol> <p>Dans <code>backend.yml</code> et <code>frontend.yml</code>, ajoutez <code>workflow_call</code> aux d\u00e9clencheurs :</p> <pre><code>on:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n  workflow_call:  # \u2728 Nouveau !\n</code></pre> <ol> <li>Cr\u00e9ez <code>.github/workflows/ci-pipeline.yml</code> :</li> </ol> <pre><code>name: CI Pipeline\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  backend:\n    name: Backend Tests\n    uses: ./.github/workflows/backend.yml\n\n  frontend:\n    name: Frontend Tests\n    uses: ./.github/workflows/frontend.yml\n\n  summary:\n    name: All Tests Passed\n    needs: [backend, frontend]\n    runs-on: ubuntu-latest\n    steps:\n      - name: \ud83c\udf89 Success\n        run: echo \"\ud83c\udf89 Tous les tests sont pass\u00e9s !\"\n</code></pre> <ol> <li>Poussez et observez :</li> </ol> <pre><code>git add .github/workflows/\ngit commit -m \"ci: add reusable workflows and pipeline\"\ngit push origin main\n</code></pre>"},{"location":"TP-2/#resultat_1","title":"\u2705 R\u00e9sultat","text":"<p>Vous verrez maintenant 3 workflows :</p> <pre><code>\u2705 Backend Tests\n\u2705 Frontend Tests\n\u2705 CI Pipeline (r\u00e9sum\u00e9 global)\n</code></pre> <p>Le job <code>summary</code> attend que backend ET frontend soient termin\u00e9s avant de s'ex\u00e9cuter.</p>"},{"location":"TP-2/#exercice-6-separer-tests-unitaires-et-e2e","title":"\u270d\ufe0f Exercice 6 : S\u00e9parer Tests Unitaires et E2E","text":""},{"location":"TP-2/#objectif_5","title":"Objectif","text":"<p>Ex\u00e9cuter les tests rapides (unitaires) sur toutes les branches, mais les tests lents (E2E) seulement sur <code>main</code>.</p>"},{"location":"TP-2/#instructions_5","title":"Instructions","text":"<p>Partie 1 : Marquer les tests E2E</p> <ol> <li>Dans <code>backend/tests/conftest.py</code>, ajoutez :</li> </ol> <pre><code>def pytest_configure(config):\n    \"\"\"Enregistre les markers personnalis\u00e9s\"\"\"\n    config.addinivalue_line(\n        \"markers\",\n        \"e2e: mark test as end-to-end test (slow)\"\n    )\n</code></pre> <ol> <li>Dans <code>backend/tests/test_api.py</code>, cr\u00e9ez un test E2E :</li> </ol> <pre><code>import pytest\n\n@pytest.mark.e2e\ndef test_complete_task_lifecycle(client):\n    \"\"\"Test E2E : CRUD complet d'une t\u00e2che.\"\"\"\n    # Cr\u00e9er\n    response = client.post(\"/tasks\", json={\n        \"title\": \"Test E2E\",\n        \"description\": \"Test complet\"\n    })\n    assert response.status_code == 201\n    task_id = response.json()[\"id\"]\n\n    # Lire\n    response = client.get(f\"/tasks/{task_id}\")\n    assert response.status_code == 200\n\n    # Mettre \u00e0 jour\n    response = client.put(f\"/tasks/{task_id}\", json={\n        \"title\": \"Updated\",\n        \"description\": \"Modified\"\n    })\n    assert response.status_code == 200\n\n    # Supprimer\n    response = client.delete(f\"/tasks/{task_id}\")\n    assert response.status_code == 204\n\n    # V\u00e9rifier suppression\n    response = client.get(f\"/tasks/{task_id}\")\n    assert response.status_code == 404\n</code></pre> <ol> <li>Testez localement les diff\u00e9rentes commandes :</li> </ol> <pre><code>cd backend\n# Tests unitaires seulement\nuv run pytest -v -m \"not e2e\"\n\n# Tests E2E seulement\nuv run pytest -v -m \"e2e\"\n\n# Tous les tests\nuv run pytest -v\n</code></pre> <p>Partie 2 : Cr\u00e9er le workflow s\u00e9par\u00e9</p> <ol> <li> <p>Cr\u00e9ez <code>.github/workflows/backend-split.yml</code> avec 2 jobs :</p> </li> <li> <p>Job 1 : unit-tests (toujours)</p> <ul> <li>Ex\u00e9cute : <code>pytest -v -m \"not e2e\"</code></li> </ul> </li> <li> <p>Job 2 : e2e-tests (seulement sur main)</p> <ul> <li>Ajoute la condition : <code>if: github.ref == 'refs/heads/main'</code></li> <li>Ex\u00e9cute : <code>pytest -v -m \"e2e\"</code></li> </ul> </li> <li> <p>Testez avec une Pull Request :</p> </li> </ol> <pre><code>git checkout -b test/split-tests\necho \"# Test\" &gt;&gt; README.md\ngit add .\ngit commit -m \"test: verify E2E don't run on PR\"\ngit push origin test/split-tests\n</code></pre>"},{"location":"TP-2/#resultat-attendu_2","title":"\u2705 R\u00e9sultat attendu","text":"<ul> <li>Sur PR : Seulement \"Unit Tests\" s'ex\u00e9cute</li> <li>Sur main : \"Unit Tests\" ET \"E2E Tests\" s'ex\u00e9cutent</li> </ul>"},{"location":"TP-2/#exercice-7-chaine-de-jobs-frontend","title":"\u270d\ufe0f Exercice 7 : Cha\u00eene de Jobs Frontend","text":""},{"location":"TP-2/#objectif_6","title":"Objectif","text":"<p>Cr\u00e9er une cha\u00eene Lint \u2192 Test \u2192 Build pour optimiser le feedback.</p>"},{"location":"TP-2/#instructions_6","title":"Instructions","text":"<ol> <li>Cr\u00e9ez <code>.github/workflows/frontend-chain.yml</code> avec 3 jobs :</li> </ol> <p>Job 1 : lint    - Installe les d\u00e9pendances    - Ex\u00e9cute : <code>npm run lint</code></p> <p>Job 2 : test    - D\u00e9pend de <code>lint</code> avec <code>needs: lint</code>    - Installe les d\u00e9pendances    - Ex\u00e9cute : <code>npm test -- --run</code></p> <p>Job 3 : build    - D\u00e9pend de <code>test</code> avec <code>needs: test</code>    - Installe les d\u00e9pendances    - Ex\u00e9cute : <code>npm run build</code>    - Upload les artifacts avec <code>actions/upload-artifact@v4</code> :</p> <pre><code> ```yaml\n - name: \ud83d\udce4 Upload build artifacts\n   uses: actions/upload-artifact@v4\n   with:\n     name: frontend-build\n     path: frontend/dist/\n ```\n</code></pre> <ol> <li>Poussez et observez :</li> </ol> <pre><code>git add .github/workflows/frontend-chain.yml\ngit commit -m \"ci: add frontend chain\"\ngit push origin main\n</code></pre>"},{"location":"TP-2/#avantages","title":"\u2705 Avantages","text":"<ul> <li>Si lint \u00e9choue \u2192 tests et build ne s'ex\u00e9cutent pas</li> <li>Feedback plus rapide (lint = 10s vs build = 2min)</li> <li>Build artifacts disponibles pour t\u00e9l\u00e9chargement</li> </ul>"},{"location":"TP-2/#exercice-8-badges-de-status","title":"\u270d\ufe0f Exercice 8 : Badges de Status","text":""},{"location":"TP-2/#objectif_7","title":"Objectif","text":"<p>Afficher le statut des workflows dans votre README.</p>"},{"location":"TP-2/#instructions_7","title":"Instructions","text":"<ol> <li>Modifiez <code>README.md</code> et ajoutez au d\u00e9but :</li> </ol> <pre><code># TaskFlow API\n\n![Backend Tests](https://github.com/VOTRE_NOM/VOTRE_REPO/workflows/Backend%20Tests/badge.svg)\n![Frontend Tests](https://github.com/VOTRE_NOM/VOTRE_REPO/workflows/Frontend%20Tests/badge.svg)\n![CI Pipeline](https://github.com/VOTRE_NOM/VOTRE_REPO/workflows/CI%20Pipeline/badge.svg)\n</code></pre> <ol> <li>Remplacez :</li> <li><code>VOTRE_NOM</code> \u2192 Votre username GitHub</li> <li> <p><code>VOTRE_REPO</code> \u2192 Nom de votre repo</p> </li> <li> <p>Poussez :</p> </li> </ol> <pre><code>git add README.md\ngit commit -m \"docs: add CI badges\"\ngit push origin main\n</code></pre>"},{"location":"TP-2/#resultat_2","title":"\u2705 R\u00e9sultat","text":"<p>Sur GitHub, vous verrez des badges qui se mettent \u00e0 jour automatiquement :</p> <pre><code>\u2705 Backend Tests  \u2705 Frontend Tests  \u2705 CI Pipeline\n</code></pre>"},{"location":"TP-2/#recapitulatif","title":"\ud83d\udccb R\u00e9capitulatif","text":"<p>F\u00e9licitations ! Vous avez maintenant :</p> <p>\u2705 Exercice 1 : Workflow backend automatis\u00e9 \u2705 Exercice 2 : Workflow frontend automatis\u00e9 \u2705 Exercice 3 : Comp\u00e9tences en d\u00e9bogage de workflows \u2705 Exercice 4 : Cache UV pour optimiser les builds \u2705 Exercice 5 : Pipeline CI global avec workflows r\u00e9utilisables \u2705 Exercice 6 : S\u00e9paration tests unitaires / E2E \u2705 Exercice 7 : Cha\u00eene de jobs frontend optimis\u00e9e \u2705 Exercice 8 : Badges de status dans le README</p> <p>Temps total estim\u00e9 : 4-5 heures</p>"},{"location":"TP-2/#erreurs-frequentes","title":"\ud83d\udc1b Erreurs Fr\u00e9quentes","text":""},{"location":"TP-2/#uv-command-not-found","title":"\u274c <code>uv: command not found</code>","text":"<p>Cause : UV n'est pas dans le PATH Solution : Ajoutez <code>echo \"$HOME/.cargo/bin\" &gt;&gt; $GITHUB_PATH</code></p>"},{"location":"TP-2/#tests-qui-passent-localement-mais-echouent-sur-github","title":"\u274c Tests qui passent localement mais \u00e9chouent sur GitHub","text":"<p>Causes possibles :</p> <ol> <li>Variable d'environnement manquante</li> <li>D\u00e9pendance syst\u00e8me manquante</li> <li>Timezone diff\u00e9rente</li> </ol> <p>D\u00e9boguer : Reproduisez exactement les m\u00eames commandes localement</p>"},{"location":"TP-2/#cache-qui-ne-fonctionne-pas","title":"\u274c Cache qui ne fonctionne pas","text":"<p>Cause : Mauvaise cl\u00e9 de cache Solution : V\u00e9rifiez que <code>hashFiles()</code> pointe vers les bons fichiers</p>"},{"location":"TP-2/#bonus-workflow-java-optionnel","title":"\ud83c\udf81 BONUS : Workflow Java (Optionnel)","text":"<p>Pour les \u00e9tudiants qui ont fait les exercices Java du TP 1.</p>"},{"location":"TP-2/#objectif_8","title":"Objectif","text":"<p>Tester automatiquement les 3 projets Java (calculator, string-utils, bank-account).</p>"},{"location":"TP-2/#instructions_8","title":"Instructions","text":"<ol> <li>Cr\u00e9ez <code>.github/workflows/java.yml</code> :</li> </ol> <pre><code>name: Java Tests (Optional)\n\non:\n  push:\n    branches: [main]\n    paths:\n      - 'java-exercises/**'\n  pull_request:\n    branches: [main]\n    paths:\n      - 'java-exercises/**'\n  workflow_dispatch:\n\njobs:\n  test:\n    name: Test Java Exercises\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: \ud83d\udce5 Checkout code\n        uses: actions/checkout@v4\n\n      - name: \u2615 Setup Java\n        uses: actions/setup-java@v4\n        with:\n          distribution: 'temurin'\n          java-version: '17'\n\n      - name: \ud83e\uddee Test Calculator\n        working-directory: java-exercises/calculator\n        run: |\n          javac -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar *.java\n          java -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar org.junit.runner.JUnitCore CalculatorTest\n\n      - name: \ud83d\udcdd Test String Utils\n        working-directory: java-exercises/string-utils\n        run: |\n          javac -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar *.java\n          java -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar org.junit.runner.JUnitCore StringUtilsTest\n\n      - name: \ud83c\udfe6 Test Bank Account\n        working-directory: java-exercises/bank-account\n        run: |\n          javac -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar *.java\n          java -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar org.junit.runner.JUnitCore BankAccountTest\n</code></pre>"},{"location":"TP-2/#nouveaux-concepts","title":"Nouveaux concepts","text":"<p><code>paths:</code> - D\u00e9clenchement conditionnel</p> <pre><code>on:\n  push:\n    paths:\n      - 'java-exercises/**'\n</code></pre> <p>Le workflow ne s'ex\u00e9cute que si vous modifiez des fichiers Java.</p> <p><code>workflow_dispatch:</code> - Lancement manuel Vous pouvez lancer le workflow manuellement depuis l'onglet Actions.</p> <p><code>working-directory:</code> - R\u00e9pertoire de travail</p> <pre><code>- name: Test Calculator\n  working-directory: java-exercises/calculator\n</code></pre> <p>Plus propre que d'utiliser <code>cd</code> dans chaque commande.</p>"},{"location":"TP-2/#test","title":"Test","text":"<p>Option 1 : Modifier un fichier Java</p> <pre><code>echo \"// Test CI\" &gt;&gt; java-exercises/calculator/Calculator.java\ngit add java-exercises/\ngit commit -m \"test: trigger Java workflow\"\ngit push\n</code></pre> <p>Option 2 : Lancement manuel</p> <ol> <li>Allez dans \"Actions\" \u2192 \"Java Tests (Optional)\"</li> <li>Cliquez sur \"Run workflow\"</li> <li>S\u00e9lectionnez \"main\" et cliquez \"Run workflow\"</li> </ol>"},{"location":"TP-3/","title":"\ud83d\ude80 TP 3 : Base de Donn\u00e9es et D\u00e9ploiement en Production","text":"<p>Dur\u00e9e estim\u00e9e : 3h00 Pr\u00e9requis : TP 1 &amp; 2 termin\u00e9s + compte GitHub</p>"},{"location":"TP-3/#objectifs-de-latelier","title":"\ud83c\udfaf Objectifs de l'Atelier","text":"<p>\u00c0 la fin de cet atelier, vous aurez :</p> <ol> <li>\u2705 Migr\u00e9 vers PostgreSQL avec SQLAlchemy ORM</li> <li>\u2705 D\u00e9ploy\u00e9 automatiquement avec render.yaml (Infrastructure as Code)</li> <li>\u2705 Ajout\u00e9 de nouvelles fonctionnalit\u00e9s (comptage de t\u00e2ches)</li> <li>\u2705 V\u00e9rifi\u00e9 le d\u00e9ploiement automatique (Continuous Deployment)</li> </ol>"},{"location":"TP-3/#architecture-cible","title":"\ud83d\udce6 Architecture Cible","text":"<p>Avant (Local - Stockage en m\u00e9moire) : <pre><code>Frontend (localhost:5173) \u2190 \u2192 Backend (localhost:8000)\n                                  \u2193\n                            Liste Python (RAM)\n                            \u274c Donn\u00e9es perdues au red\u00e9marrage\n</code></pre></p> <p>Apr\u00e8s (Production avec PostgreSQL) : <pre><code>Frontend (Render)                Backend (Render)              Database (Render)\ntaskflow-frontend.onrender.com \u2192 taskflow-backend.onrender.com \u2192 PostgreSQL\n         HTTPS                            HTTPS + CORS                256 MB\n                                                                  \u2705 Donn\u00e9es persistantes\n</code></pre></p>"},{"location":"TP-3/#pourquoi-postgresql","title":"\ud83c\udfaf Pourquoi PostgreSQL ?","text":"<p>Probl\u00e8me actuel : Les donn\u00e9es sont stock\u00e9es dans une liste Python en m\u00e9moire - \u274c Donn\u00e9es perdues \u00e0 chaque red\u00e9marrage - \u274c Impossible de scaler (plusieurs instances) - \u274c Pas de requ\u00eates complexes</p> <p>Avec PostgreSQL : - \u2705 Donn\u00e9es persistantes - \u2705 Requ\u00eates SQL puissantes - \u2705 Base de donn\u00e9es professionnelle - \u2705 Gratuit sur Render</p>"},{"location":"TP-3/#exercice-1-installer-les-dependances-postgresql","title":"\u270d\ufe0f Exercice 1 : Installer les D\u00e9pendances PostgreSQL","text":""},{"location":"TP-3/#objectif","title":"Objectif","text":"<p>Ajouter SQLAlchemy et le driver PostgreSQL au backend.</p>"},{"location":"TP-3/#instructions","title":"Instructions","text":"<ol> <li> <p>Ajoutez les packages n\u00e9cessaires : <pre><code>cd backend\nuv add sqlalchemy psycopg2-binary\n</code></pre></p> </li> <li> <p>V\u00e9rifiez l'installation : <pre><code>uv run python -c \"import sqlalchemy; print(f'SQLAlchemy {sqlalchemy.__version__}')\"\n</code></pre></p> </li> </ol>"},{"location":"TP-3/#resultat-attendu","title":"\u2705 R\u00e9sultat attendu","text":"<p>Vous devriez voir la version de SQLAlchemy s'afficher (ex: <code>SQLAlchemy 2.0.25</code>)</p>"},{"location":"TP-3/#ce-que-font-ces-packages","title":"\ud83d\udca1 Ce que font ces packages","text":"<ul> <li><code>sqlalchemy</code> : ORM (Object-Relational Mapping) pour Python - permet de manipuler la base de donn\u00e9es avec des objets Python</li> <li><code>psycopg2-binary</code> : Driver PostgreSQL - permet \u00e0 Python de se connecter \u00e0 PostgreSQL</li> </ul>"},{"location":"TP-3/#exercice-2-configurer-la-base-de-donnees","title":"\u270d\ufe0f Exercice 2 : Configurer la Base de Donn\u00e9es","text":""},{"location":"TP-3/#objectif_1","title":"Objectif","text":"<p>Cr\u00e9er le fichier de configuration pour la connexion \u00e0 la base de donn\u00e9es.</p>"},{"location":"TP-3/#instructions_1","title":"Instructions","text":"<ol> <li> <p>Cr\u00e9ez le fichier <code>backend/src/database.py</code></p> </li> <li> <p>Ajoutez la configuration suivante :</p> </li> <li>Importer les modules n\u00e9cessaires : <code>sqlalchemy</code>, <code>sessionmaker</code>, <code>declarative_base</code></li> <li>Lire <code>DATABASE_URL</code> depuis les variables d'environnement (d\u00e9faut: <code>sqlite:///./taskflow.db</code>)</li> <li>Cr\u00e9er un moteur SQLAlchemy avec <code>create_engine()</code></li> <li>Pour SQLite : ajouter <code>connect_args={\"check_same_thread\": False}</code></li> <li>Pour PostgreSQL : configurer la pool de connexions avec <code>pool_size=5</code>, <code>max_overflow=10</code>, <code>pool_pre_ping=True</code></li> <li>Cr\u00e9er une factory de sessions avec <code>sessionmaker()</code></li> <li> <p>Cr\u00e9er une <code>Base</code> avec <code>declarative_base()</code> pour les mod\u00e8les ORM</p> </li> <li> <p>Ajoutez deux fonctions :</p> </li> <li><code>get_db()</code> : G\u00e9n\u00e9rateur qui fournit une session de base de donn\u00e9es (pour FastAPI Depends)</li> <li><code>init_db()</code> : Initialise la base de donn\u00e9es en cr\u00e9ant toutes les tables</li> </ol>"},{"location":"TP-3/#points-importants","title":"\ud83d\udca1 Points importants","text":"<ul> <li><code>DATABASE_URL</code> : URL de connexion (SQLite en local, PostgreSQL en production)</li> <li>Pool de connexions : R\u00e9utilise les connexions pour am\u00e9liorer les performances</li> <li><code>pool_pre_ping</code> : V\u00e9rifie que la connexion est vivante avant de l'utiliser</li> </ul>"},{"location":"TP-3/#exercice-3-creer-le-modele-de-donnees","title":"\u270d\ufe0f Exercice 3 : Cr\u00e9er le Mod\u00e8le de Donn\u00e9es","text":""},{"location":"TP-3/#objectif_2","title":"Objectif","text":"<p>D\u00e9finir le sch\u00e9ma de la table <code>tasks</code> avec SQLAlchemy ORM.</p>"},{"location":"TP-3/#instructions_2","title":"Instructions","text":"<ol> <li> <p>Cr\u00e9ez le fichier <code>backend/src/models.py</code></p> </li> <li> <p>D\u00e9placez les enums depuis <code>app.py</code> :</p> </li> <li><code>TaskStatus</code> : todo, in_progress, done</li> <li> <p><code>TaskPriority</code> : low, medium, high</p> </li> <li> <p>Cr\u00e9ez la classe <code>TaskModel</code> qui h\u00e9rite de <code>Base</code> :</p> </li> <li>D\u00e9finir <code>__tablename__ = \"tasks\"</code></li> <li>Ajouter les colonnes avec <code>Column()</code> :<ul> <li><code>id</code> : String, primary key, index</li> <li><code>title</code> : String(200), non nullable</li> <li><code>description</code> : String(1000), nullable</li> <li><code>status</code> : Enum (TaskStatus), d\u00e9faut TODO</li> <li><code>priority</code> : Enum (TaskPriority), d\u00e9faut MEDIUM</li> <li><code>assignee</code> : String(100), nullable</li> <li><code>due_date</code> : DateTime, nullable</li> <li><code>created_at</code> : DateTime, auto (server_default=func.now())</li> <li><code>updated_at</code> : DateTime, auto (server_default=func.now(), onupdate=func.now())</li> </ul> </li> </ol>"},{"location":"TP-3/#avantages-de-lorm","title":"\ud83d\udca1 Avantages de l'ORM","text":"<ul> <li>Pas besoin d'\u00e9crire du SQL directement</li> <li>Type-safety avec Python</li> <li>Migrations de sch\u00e9ma facilit\u00e9es</li> <li>Timestamps automatiques</li> </ul>"},{"location":"TP-3/#exercice-4-migrer-lapplication-vers-postgresql","title":"\u270d\ufe0f Exercice 4 : Migrer l'Application vers PostgreSQL","text":""},{"location":"TP-3/#objectif_3","title":"Objectif","text":"<p>Adapter <code>app.py</code> pour utiliser SQLAlchemy au lieu du stockage en m\u00e9moire.</p>"},{"location":"TP-3/#instructions_3","title":"Instructions","text":"<p>Partie 1 : Imports et nettoyage</p> <ol> <li>Ajoutez les imports n\u00e9cessaires :</li> <li><code>from sqlalchemy.orm import Session</code></li> <li><code>from sqlalchemy import text</code></li> <li><code>from .database import get_db, init_db</code></li> <li> <p><code>from .models import TaskModel, TaskStatus, TaskPriority</code></p> </li> <li> <p>Supprimez l'ancien code :</p> </li> <li>\u274c Supprimez les d\u00e9finitions de <code>TaskStatus</code> et <code>TaskPriority</code> (maintenant dans models.py)</li> <li>\u274c Supprimez <code>tasks_storage: List[Task] = []</code></li> <li>\u274c Supprimez les fonctions <code>clear_tasks()</code> et <code>get_tasks_storage()</code></li> </ol> <p>Partie 2 : Modifier le lifespan</p> <ol> <li>Dans la fonction <code>lifespan()</code>, appelez <code>init_db()</code> au d\u00e9marrage</li> </ol> <p>Partie 3 : Modifier les endpoints (utilisez <code>db: Session = Depends(get_db)</code>)</p> <ol> <li>GET /tasks :</li> <li> <p>R\u00e9cup\u00e9rer toutes les t\u00e2ches avec <code>db.query(TaskModel).all()</code></p> </li> <li> <p>POST /tasks :</p> </li> <li>Cr\u00e9er un <code>TaskModel</code> avec les donn\u00e9es re\u00e7ues</li> <li>Ajouter \u00e0 la session avec <code>db.add()</code></li> <li>Sauvegarder avec <code>db.commit()</code></li> <li> <p>Rafra\u00eechir avec <code>db.refresh()</code></p> </li> <li> <p>GET /tasks/{task_id} :</p> </li> <li>Chercher avec <code>db.query(TaskModel).filter(TaskModel.id == task_id).first()</code></li> <li> <p>Lever <code>HTTPException(404)</code> si non trouv\u00e9</p> </li> <li> <p>PUT /tasks/{task_id} :</p> </li> <li>Chercher la t\u00e2che</li> <li>Mettre \u00e0 jour les champs avec <code>setattr()</code></li> <li> <p>Commit et refresh</p> </li> <li> <p>DELETE /tasks/{task_id} :</p> </li> <li>Chercher la t\u00e2che</li> <li>Supprimer avec <code>db.delete()</code></li> <li> <p>Commit</p> </li> <li> <p>Am\u00e9liorer /health :</p> </li> <li>Tester la connexion DB avec <code>db.execute(text(\"SELECT 1\"))</code></li> <li>Compter les t\u00e2ches avec <code>db.query(TaskModel).count()</code></li> <li>Retourner le statut de la DB et le nombre de t\u00e2ches</li> </ol>"},{"location":"TP-3/#checkpoint","title":"\u2705 Checkpoint","text":"<p>Testez localement : <pre><code>cd backend\nuv run uvicorn src.app:app --reload\n\n# Dans un autre terminal\ncurl http://localhost:8000/health\ncurl http://localhost:8000/tasks\n</code></pre></p> <p>Vous devriez voir un fichier <code>taskflow.db</code> cr\u00e9\u00e9 dans <code>backend/</code></p>"},{"location":"TP-3/#exercice-5-adapter-les-tests","title":"\u270d\ufe0f Exercice 5 : Adapter les Tests","text":""},{"location":"TP-3/#objectif_4","title":"Objectif","text":"<p>Modifier les tests pour utiliser une base de donn\u00e9es SQLite temporaire.</p>"},{"location":"TP-3/#instructions_4","title":"Instructions","text":"<ol> <li>Dans <code>backend/tests/conftest.py</code>, modifiez la fixture :</li> <li>Cr\u00e9er une base de donn\u00e9es de test temporaire avec <code>tempfile.mktemp()</code></li> <li>Cr\u00e9er un moteur de test avec <code>create_engine(TEST_DATABASE_URL)</code></li> <li>Cr\u00e9er une factory de sessions de test avec <code>sessionmaker()</code></li> <li>Fixture <code>setup_test_database</code> (scope=\"session\") : cr\u00e9er toutes les tables</li> <li>Fixture <code>clear_test_data</code> (autouse=True) : nettoyer entre chaque test</li> <li> <p>Fixture <code>client</code> : override <code>get_db</code> pour utiliser la DB de test</p> </li> <li> <p>Lancez les tests : <pre><code>cd backend\nuv run pytest -v\n</code></pre></p> </li> </ol>"},{"location":"TP-3/#resultat-attendu_1","title":"\u2705 R\u00e9sultat attendu","text":"<p>Tous les tests doivent passer (19+ tests)</p>"},{"location":"TP-3/#exercice-6-creer-un-compte-render","title":"\u270d\ufe0f Exercice 6 : Cr\u00e9er un Compte Render","text":""},{"location":"TP-3/#objectif_5","title":"Objectif","text":"<p>Pr\u00e9parer le d\u00e9ploiement sur Render.</p>"},{"location":"TP-3/#instructions_5","title":"Instructions","text":"<ol> <li>Cr\u00e9er un compte Render :</li> <li>Allez sur https://render.com</li> <li>Cliquez \"Get Started\"</li> <li>Inscrivez-vous avec votre compte GitHub</li> <li> <p>Autorisez Render \u00e0 acc\u00e9der \u00e0 vos repositories</p> </li> <li> <p>Explorez le Dashboard :</p> </li> <li>Familiarisez-vous avec l'interface</li> <li>Notez le bouton \"New +\" pour cr\u00e9er des services</li> </ol>"},{"location":"TP-3/#render-vs-heroku","title":"\ud83d\udca1 Render vs Heroku","text":"<ul> <li>\u2705 Gratuit pour PostgreSQL + 2 services</li> <li>\u2705 D\u00e9ploiement automatique depuis GitHub</li> <li>\u2705 Infrastructure as Code avec <code>render.yaml</code></li> <li>\u2705 HTTPS automatique</li> </ul>"},{"location":"TP-3/#exercice-7-comprendre-renderyaml","title":"\u270d\ufe0f Exercice 7 : Comprendre render.yaml","text":""},{"location":"TP-3/#objectif_6","title":"Objectif","text":"<p>Comprendre l'Infrastructure as Code pour Render.</p>"},{"location":"TP-3/#instructions_6","title":"Instructions","text":"<ol> <li> <p>Ouvrez <code>render.yaml</code> \u00e0 la racine du projet</p> </li> <li> <p>Analysez la structure :</p> </li> </ol> <p>Section <code>databases</code> : - D\u00e9finit une base PostgreSQL gratuite - R\u00e9gion : Frankfurt (proche de vous) - Nom : <code>taskflow-db</code></p> <p>Section <code>services</code> (Backend) : - Type : <code>web</code> (service HTTP) - Runtime : <code>python</code> - Build command : installe UV et les d\u00e9pendances - Start command : lance uvicorn - Variables d'environnement :   - <code>DATABASE_URL</code> : inject\u00e9e automatiquement depuis la DB   - <code>CORS_ORIGINS</code> : \u00e0 configurer manuellement - Health check : <code>/health</code></p> <p>Section <code>services</code> (Frontend) : - Type : <code>web</code> - Runtime : <code>static</code> (site statique) - Build command : <code>npm ci &amp;&amp; npm run build</code> - Publish path : <code>frontend/dist</code> - Variable : <code>VITE_API_URL</code> \u00e0 configurer</p>"},{"location":"TP-3/#avantages-de-renderyaml","title":"\ud83d\udca1 Avantages de render.yaml","text":"<ul> <li>\u2705 Toute l'infrastructure est versionn\u00e9e dans Git</li> <li>\u2705 D\u00e9ploiement reproductible</li> <li>\u2705 Cr\u00e9ation automatique de tous les services</li> <li>\u2705 Injection automatique de DATABASE_URL</li> </ul>"},{"location":"TP-3/#exercice-8-deployer-avec-blueprint","title":"\u270d\ufe0f Exercice 8 : D\u00e9ployer avec Blueprint","text":""},{"location":"TP-3/#objectif_7","title":"Objectif","text":"<p>D\u00e9ployer toute l'application sur Render en un clic.</p>"},{"location":"TP-3/#instructions_7","title":"Instructions","text":"<ol> <li> <p>Assurez-vous que vos changements sont pouss\u00e9s sur GitHub : <pre><code>git add .\ngit commit -m \"feat: migrate to PostgreSQL with SQLAlchemy\"\ngit push origin main\n</code></pre></p> </li> <li> <p>Sur Render Dashboard :</p> </li> <li>Cliquez \"New +\" \u2192 \"Blueprint\"</li> <li>S\u00e9lectionnez votre repository</li> <li>Render d\u00e9tecte automatiquement <code>render.yaml</code></li> <li> <p>Cliquez \"Apply\"</p> </li> <li> <p>Attendez le d\u00e9ploiement (5-7 minutes) :</p> </li> <li> <p>3 services vont \u00eatre cr\u00e9\u00e9s :</p> <ul> <li><code>taskflow-db</code> (PostgreSQL)</li> <li><code>taskflow-backend</code> (FastAPI)</li> <li><code>taskflow-frontend</code> (React)</li> </ul> </li> <li> <p>Notez les URLs g\u00e9n\u00e9r\u00e9es : <pre><code>Backend:  https://taskflow-backend-XXXX.onrender.com\nFrontend: https://taskflow-frontend-YYYY.onrender.com\n</code></pre></p> </li> </ol>"},{"location":"TP-3/#pendant-lattente","title":"\u23f3 Pendant l'attente","text":"<p>Observez les logs de build en temps r\u00e9el pour chaque service.</p>"},{"location":"TP-3/#exercice-9-configurer-cors-et-api-url","title":"\u270d\ufe0f Exercice 9 : Configurer CORS et API URL","text":""},{"location":"TP-3/#objectif_8","title":"Objectif","text":"<p>Connecter le frontend au backend en production.</p>"},{"location":"TP-3/#instructions_8","title":"Instructions","text":"<ol> <li>Configurer le Backend :</li> <li>Dashboard \u2192 taskflow-backend \u2192 Environment</li> <li>Ajoutez : <code>CORS_ORIGINS = https://taskflow-frontend-YYYY.onrender.com</code></li> <li>(Remplacez YYYY par votre ID frontend)</li> <li>Cliquez \"Save Changes\"</li> <li> <p>Attendez le red\u00e9ploiement automatique (2-3 min)</p> </li> <li> <p>Configurer le Frontend :</p> </li> <li>Dashboard \u2192 taskflow-frontend \u2192 Environment</li> <li>Ajoutez : <code>VITE_API_URL = https://taskflow-backend-XXXX.onrender.com</code></li> <li>(Remplacez XXXX par votre ID backend)</li> <li>Cliquez \"Save Changes\"</li> <li>Attendez le red\u00e9ploiement automatique (2-3 min)</li> </ol>"},{"location":"TP-3/#resultat-attendu_2","title":"\u2705 R\u00e9sultat attendu","text":"<p>Les deux services red\u00e9marrent automatiquement avec les nouvelles configurations.</p>"},{"location":"TP-3/#exercice-10-verifier-le-deploiement","title":"\u270d\ufe0f Exercice 10 : V\u00e9rifier le D\u00e9ploiement","text":""},{"location":"TP-3/#objectif_9","title":"Objectif","text":"<p>Tester que tout fonctionne en production.</p>"},{"location":"TP-3/#instructions_9","title":"Instructions","text":"<ol> <li>Testez l'API Backend : <pre><code># Health check\ncurl https://taskflow-backend-XXXX.onrender.com/health\n</code></pre></li> </ol> <p>Vous devriez voir :    <pre><code>{\n  \"status\": \"healthy\",\n  \"database\": \"connected\",\n  \"tasks_count\": 0,\n  \"environment\": \"production\"\n}\n</code></pre></p> <ol> <li> <p>Cr\u00e9ez une t\u00e2che : <pre><code>curl -X POST https://taskflow-backend-XXXX.onrender.com/tasks \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"Test production\",\n    \"status\": \"todo\",\n    \"priority\": \"high\"\n  }'\n</code></pre></p> </li> <li> <p>Listez les t\u00e2ches : <pre><code>curl https://taskflow-backend-XXXX.onrender.com/tasks\n</code></pre></p> </li> <li> <p>Testez le Frontend :</p> </li> <li>Ouvrez <code>https://taskflow-frontend-YYYY.onrender.com</code></li> <li>Cr\u00e9ez plusieurs t\u00e2ches</li> <li>Modifiez une t\u00e2che</li> <li>Supprimez une t\u00e2che</li> </ol>"},{"location":"TP-3/#resultat-attendu_3","title":"\u2705 R\u00e9sultat attendu","text":"<p>Tout fonctionne parfaitement! \ud83c\udf89</p>"},{"location":"TP-3/#exercice-11-verifier-la-persistence","title":"\u270d\ufe0f Exercice 11 : V\u00e9rifier la Persistence","text":""},{"location":"TP-3/#objectif_10","title":"Objectif","text":"<p>Prouver que PostgreSQL persiste les donn\u00e9es.</p>"},{"location":"TP-3/#instructions_10","title":"Instructions","text":"<ol> <li> <p>Cr\u00e9ez 3-4 t\u00e2ches depuis le frontend</p> </li> <li> <p>Forcez un red\u00e9ploiement :</p> </li> <li>Dashboard \u2192 taskflow-backend</li> <li>Cliquez \"Manual Deploy\" \u2192 \"Deploy latest commit\"</li> <li> <p>Attendez le red\u00e9ploiement (2-3 minutes)</p> </li> <li> <p>Rafra\u00eechissez votre frontend</p> </li> </ol>"},{"location":"TP-3/#resultat-attendu_4","title":"\u2705 R\u00e9sultat attendu","text":"<p>Les t\u00e2ches sont toujours l\u00e0! PostgreSQL conserve les donn\u00e9es entre les red\u00e9marrages.</p>"},{"location":"TP-3/#exercice-12-explorer-la-base-de-donnees","title":"\u270d\ufe0f Exercice 12 : Explorer la Base de Donn\u00e9es","text":""},{"location":"TP-3/#objectif_11","title":"Objectif","text":"<p>Voir directement les donn\u00e9es dans PostgreSQL.</p>"},{"location":"TP-3/#instructions_11","title":"Instructions","text":"<ol> <li>Ouvrez le shell PostgreSQL :</li> <li> <p>Dashboard \u2192 taskflow-db \u2192 Shell</p> </li> <li> <p>Ex\u00e9cutez ces commandes SQL : <pre><code>-- Voir toutes les tables\n\\dt\n\n-- Voir la structure de la table tasks\n\\d tasks\n\n-- Voir toutes les t\u00e2ches\nSELECT id, title, status, priority, created_at FROM tasks;\n\n-- Compter les t\u00e2ches par statut\nSELECT status, COUNT(*) FROM tasks GROUP BY status;\n</code></pre></p> </li> </ol>"},{"location":"TP-3/#resultat-attendu_5","title":"\u2705 R\u00e9sultat attendu","text":"<p>Vous voyez vos donn\u00e9es stock\u00e9es dans PostgreSQL!</p>"},{"location":"TP-3/#exercice-13-ajouter-une-nouvelle-fonctionnalite","title":"\u270d\ufe0f Exercice 13 : Ajouter une Nouvelle Fonctionnalit\u00e9","text":""},{"location":"TP-3/#objectif_12","title":"Objectif","text":"<p>D\u00e9montrer le d\u00e9ploiement automatique en ajoutant un endpoint simple.</p>"},{"location":"TP-3/#instructions_12","title":"Instructions","text":"<ol> <li> <p>Dans <code>backend/src/app.py</code>, ajoutez un endpoint de comptage : <pre><code>@app.get(\"/tasks/count\")\nasync def count_tasks(db: Session = Depends(get_db)):\n    \"\"\"Count total number of tasks.\"\"\"\n    logger.info(\"Counting tasks\")\n    total = db.query(TaskModel).count()\n    return {\"total\": total}\n</code></pre></p> </li> <li> <p>Testez localement : <pre><code>cd backend\nuv run uvicorn src.app:app --reload\n\n# Dans un autre terminal\ncurl http://localhost:8000/tasks/count\n</code></pre></p> </li> <li> <p>Ajoutez un test dans <code>backend/tests/test_count.py</code> : <pre><code>def test_count_tasks(client):\n    \"\"\"Test counting tasks.\"\"\"\n    # Au d\u00e9but, 0 t\u00e2ches\n    response = client.get(\"/tasks/count\")\n    assert response.status_code == 200\n    assert response.json()[\"total\"] == 0\n\n    # Cr\u00e9er 3 t\u00e2ches\n    for i in range(3):\n        client.post(\"/tasks\", json={\n            \"title\": f\"Task {i+1}\",\n            \"status\": \"todo\",\n            \"priority\": \"medium\"\n        })\n\n    # Maintenant, 3 t\u00e2ches\n    response = client.get(\"/tasks/count\")\n    assert response.status_code == 200\n    assert response.json()[\"total\"] == 3\n</code></pre></p> </li> <li> <p>V\u00e9rifiez que les tests passent : <pre><code>uv run pytest -v\n</code></pre></p> </li> </ol>"},{"location":"TP-3/#resultat-attendu_6","title":"\u2705 R\u00e9sultat attendu","text":"<p>Tous les tests passent (20+ tests maintenant)</p>"},{"location":"TP-3/#exercice-14-deployer-la-nouvelle-fonctionnalite","title":"\u270d\ufe0f Exercice 14 : D\u00e9ployer la Nouvelle Fonctionnalit\u00e9","text":""},{"location":"TP-3/#objectif_13","title":"Objectif","text":"<p>Observer le cycle complet CI/CD automatique.</p>"},{"location":"TP-3/#instructions_13","title":"Instructions","text":"<ol> <li> <p>Committez et poussez : <pre><code>git add .\ngit commit -m \"feat: add task count endpoint\n\n- Add GET /tasks/count endpoint\n- Add test for count endpoint\n- Returns total number of tasks in database\"\n\ngit push origin main\n</code></pre></p> </li> <li> <p>Observez GitHub Actions (1-2 min) :</p> </li> <li>GitHub \u2192 Actions</li> <li>Workflow d\u00e9marre automatiquement</li> <li>Backend tests \u2705</li> <li> <p>Frontend tests \u2705</p> </li> <li> <p>Observez Render Auto-Deploy (3-5 min) :</p> </li> <li>Render Dashboard \u2192 taskflow-backend</li> <li>Status : \"Deploying...\"</li> <li> <p>Observez les logs de build en temps r\u00e9el</p> </li> <li> <p>Testez en production : <pre><code>curl https://taskflow-backend-XXXX.onrender.com/tasks/count\n</code></pre></p> </li> <li> <p>V\u00e9rifiez dans Swagger UI :</p> </li> <li>Ouvrez : <code>https://taskflow-backend-XXXX.onrender.com/docs</code></li> <li>Le nouveau endpoint <code>GET /tasks/count</code> appara\u00eet</li> <li>Testez-le avec \"Try it out\"</li> </ol>"},{"location":"TP-3/#resultat-attendu_7","title":"\u2705 R\u00e9sultat attendu","text":"<p>La nouvelle fonctionnalit\u00e9 est d\u00e9ploy\u00e9e automatiquement! \ud83d\ude80</p>"},{"location":"TP-3/#workflow-complet-cicd","title":"\ud83d\udcca Workflow Complet CI/CD","text":"<p>Ce qui s'est pass\u00e9 automatiquement :</p> <pre><code>1. git push origin main\n   \u2193\n2. GitHub Actions d\u00e9marre\n   \u251c\u2500 Backend: uv run pytest \u2705\n   \u251c\u2500 Frontend: npm test \u2705\n   \u2514\u2500 Les tests passent\n   \u2193\n3. Render d\u00e9tecte le push\n   \u2193\n4. Render clone le nouveau code\n   \u2193\n5. Render rebuild le backend\n   \u251c\u2500 pip install uv\n   \u251c\u2500 uv sync (install dependencies)\n   \u2514\u2500 uv run uvicorn (start server)\n   \u2193\n6. Health check: /health \u2705\n   \u2193\n7. \ud83c\udf89 Nouvelle version LIVE !\n\nTemps total: ~5-7 minutes\n</code></pre> <p>Zero configuration n\u00e9cessaire ! Tout est automatique gr\u00e2ce \u00e0 : - <code>.github/workflows/backend.yml</code> (tests) - <code>render.yaml</code> (d\u00e9ploiement)</p>"},{"location":"TP-3/#recapitulatif","title":"\ud83d\udccb R\u00e9capitulatif","text":"<p>F\u00e9licitations ! Vous avez maintenant :</p> <p>\u2705 Exercice 1 : Install\u00e9 SQLAlchemy et psycopg2 \u2705 Exercice 2 : Configur\u00e9 la connexion \u00e0 la base de donn\u00e9es \u2705 Exercice 3 : Cr\u00e9\u00e9 le mod\u00e8le ORM TaskModel \u2705 Exercice 4 : Migr\u00e9 app.py vers PostgreSQL \u2705 Exercice 5 : Adapt\u00e9 les tests avec une DB temporaire \u2705 Exercice 6 : Cr\u00e9\u00e9 un compte Render \u2705 Exercice 7 : Compris render.yaml (IaC) \u2705 Exercice 8 : D\u00e9ploy\u00e9 avec Blueprint en un clic \u2705 Exercice 9 : Configur\u00e9 CORS et API URL \u2705 Exercice 10 : V\u00e9rifi\u00e9 le d\u00e9ploiement en production \u2705 Exercice 11 : Prouv\u00e9 la persistence des donn\u00e9es \u2705 Exercice 12 : Explor\u00e9 PostgreSQL avec SQL \u2705 Exercice 13 : Ajout\u00e9 un endpoint de comptage \u2705 Exercice 14 : D\u00e9ploy\u00e9 automatiquement avec CD</p> <p>Temps total estim\u00e9 : 3 heures</p>"},{"location":"TP-3/#ce-que-vous-avez-appris","title":"\ud83d\udcda Ce que Vous Avez Appris","text":"<p>\u2705 SQLAlchemy ORM - Mod\u00e8les Python \u2194 Tables SQL \u2705 PostgreSQL - Base de donn\u00e9es relationnelle professionnelle \u2705 Infrastructure as Code - render.yaml pour d\u00e9finir l'infra \u2705 Continuous Deployment - Push \u2192 Tests \u2192 Deploy automatique \u2705 API REST - Nouveaux endpoints avec tests \u2705 Production monitoring - Logs, health checks, database status \u2705 Data persistence - Les donn\u00e9es survivent aux red\u00e9marrages</p>"},{"location":"TP-3/#pour-aller-plus-loin","title":"\ud83d\ude80 Pour Aller Plus Loin","text":""},{"location":"TP-3/#fonctionnalites-simples-30-min-chacune","title":"Fonctionnalit\u00e9s Simples (30 min chacune)","text":"<ol> <li>Endpoint de recherche : <code>GET /tasks/search?q=query</code></li> <li>Endpoint de filtrage : <code>GET /tasks/filter/{status}</code></li> <li>Endpoint de statistiques : <code>GET /tasks/stats</code> (compte par statut/priorit\u00e9)</li> <li>Badge de comptage : Afficher le count dans le frontend</li> </ol>"},{"location":"TP-3/#fonctionnalites-avancees-1-2h-chacune","title":"Fonctionnalit\u00e9s Avanc\u00e9es (1-2h chacune)","text":"<ol> <li>Pagination : Ajouter <code>skip</code> et <code>limit</code> aux endpoints</li> <li>Authentification : JWT tokens avec FastAPI Security</li> <li>Filtrage UI : Boutons pour filtrer par statut dans le frontend</li> <li>Dashboard de stats : Graphiques avec Chart.js</li> </ol>"},{"location":"TP-3/#devops-avance","title":"DevOps Avanc\u00e9","text":"<ol> <li>Monitoring : Int\u00e9grer Sentry pour error tracking</li> <li>Staging Environment : Environnement de pr\u00e9-production</li> <li>Database Migrations : Alembic pour migrations SQL</li> <li>Custom Domain : Utiliser votre propre nom de domaine</li> </ol>"},{"location":"TP-3/#checklist-de-fin-datelier","title":"\u2705 Checklist de Fin d'Atelier","text":"<p>Migration PostgreSQL : - [ ] SQLAlchemy et psycopg2 install\u00e9s - [ ] <code>database.py</code> cr\u00e9\u00e9 avec configuration - [ ] <code>models.py</code> cr\u00e9\u00e9 avec TaskModel - [ ] <code>app.py</code> migr\u00e9 pour utiliser la DB - [ ] Tests adapt\u00e9s avec base de test - [ ] Tests locaux passent</p> <p>D\u00e9ploiement : - [ ] Compte Render cr\u00e9\u00e9 - [ ] <code>render.yaml</code> compris - [ ] Blueprint d\u00e9ploy\u00e9 avec succ\u00e8s - [ ] Backend accessible via HTTPS - [ ] Frontend accessible via HTTPS - [ ] CORS configur\u00e9 - [ ] PostgreSQL connect\u00e9e</p> <p>Continuous Deployment : - [ ] Push d\u00e9clenche GitHub Actions - [ ] Tests passent automatiquement - [ ] Render auto-deploy fonctionne - [ ] Nouvelles fonctionnalit\u00e9s visibles en prod - [ ] Donn\u00e9es persistent apr\u00e8s red\u00e9ploiement</p> <p>Si tout est coch\u00e9 : Bravo, vous ma\u00eetrisez le cycle complet ! \ud83c\udf89\ud83d\ude80</p>"},{"location":"TP-3/#ressources","title":"\ud83d\udcda Ressources","text":"<p>Documentation Technique : - SQLAlchemy Docs - FastAPI Database Guide - Render Blueprint Spec - PostgreSQL Docs</p> <p>Version 5.0 - TP 3 : Base de Donn\u00e9es et D\u00e9ploiement en Production (3h)</p>"}]}