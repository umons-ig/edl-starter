# üöÄ TP 2 : CI/CD avec GitHub Actions

**Pr√©requis :** TP 1 termin√© (backend et frontend avec tests)

## üéØ Objectifs de l'Atelier

**Objectif principal :** Automatiser les tests avec GitHub Actions

√Ä la fin de cet atelier, vous aurez :

1. ‚úÖ Cr√©√© un **workflow backend** qui teste automatiquement votre code Python
2. ‚úÖ Cr√©√© un **workflow frontend** qui teste et build votre code TypeScript
3. ‚úÖ Compris comment **d√©boguer** un workflow qui √©choue
4. ‚úÖ Optimis√© vos workflows avec le **cache**
5. ‚úÖ Cr√©√© des **workflows r√©utilisables** et des **pipelines CI**
6. ‚úÖ S√©par√© les **tests rapides** (unitaires) des **tests lents** (E2E)
7. ‚úÖ Ajout√© des **badges de status** √† votre README

---

## üì¶ Qu'est-ce que CI/CD ?

**CI (Continuous Integration) :**

- Int√©gration Continue
- √Ä chaque push, les tests s'ex√©cutent automatiquement
- D√©tecte les bugs imm√©diatement

**CD (Continuous Deployment) :**

- D√©ploiement Continu (TP 3)
- Si les tests passent, d√©ploiement automatique

**GitHub Actions :**

- Service gratuit de GitHub
- Ex√©cute vos tests sur des serveurs GitHub
- V√©rifie chaque commit et pull request

---

## üìö Structure d'un Workflow GitHub Actions

Un workflow GitHub Actions est un fichier **YAML** dans `.github/workflows/`.

**Structure de base :**

```yaml
name: Mon Workflow          # 1Ô∏è‚É£ Nom affich√© dans GitHub

on:                         # 2Ô∏è‚É£ Quand s'ex√©cute-t-il ?
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:                       # 3Ô∏è‚É£ Les t√¢ches √† faire
  test:
    runs-on: ubuntu-latest  # 4Ô∏è‚É£ Machine virtuelle
    steps:                  # 5Ô∏è‚É£ Les √©tapes
      - uses: actions/checkout@v4
      - run: pytest
```

**Concepts cl√©s :**

- **`name`** : Nom du workflow
- **`on`** : D√©clencheurs (push, pull_request, etc.)
- **`jobs`** : T√¢ches parall√®les
- **`steps`** : √âtapes s√©quentielles
- **`uses`** : Action pr√©-faite
- **`run`** : Commande shell

---

## ‚úçÔ∏è Exercice 1 : Workflow Backend

### Objectif

Cr√©er un workflow qui teste automatiquement le backend √† chaque push.

### Instructions

1. **Cr√©ez la structure des workflows :**

   ```bash
   mkdir -p .github/workflows
   ```

2. **Cr√©ez le fichier `.github/workflows/backend.yml`**

3. **Configurez le workflow avec :**
   - Nom : "Backend Tests"
   - D√©clencheurs : push et pull_request sur `main`
   - Job nomm√© "test" qui s'ex√©cute sur `ubuntu-latest`

4. **Ajoutez les √©tapes suivantes (dans l'ordre) :**
   - R√©cup√©rer le code avec `actions/checkout@v4`
   - Installer Python 3.11 avec `actions/setup-python@v5`
   - Installer UV :

     ```bash
     curl -LsSf https://astral.sh/uv/install.sh | sh
     echo "$HOME/.cargo/bin" >> $GITHUB_PATH
     ```

   - Installer les d√©pendances : `cd backend && uv sync`
   - Lancer les tests : `cd backend && uv run pytest -v --cov`

5. **Testez localement avant de pousser :**

   ```bash
   cd backend
   uv run pytest -v --cov
   ```

6. **Poussez et v√©rifiez sur GitHub Actions :**

   ```bash
   git add .github/workflows/backend.yml
   git commit -m "ci: add backend workflow"
   git push origin main
   ```

### ‚úÖ R√©sultat attendu

Dans l'onglet "Actions" sur GitHub, vous devriez voir :

```
‚úÖ Backend Tests
  ‚îî‚îÄ test
      ‚îú‚îÄ Checkout code
      ‚îú‚îÄ Setup Python
      ‚îú‚îÄ Install UV
      ‚îú‚îÄ Install dependencies
      ‚îî‚îÄ Run tests
```

---

## ‚úçÔ∏è Exercice 2 : Workflow Frontend

### Objectif

Cr√©er un workflow qui teste et build le frontend automatiquement.

### Instructions

1. **Cr√©ez le fichier `.github/workflows/frontend.yml`**

2. **Configurez le workflow similairement au backend :**
   - Nom : "Frontend Tests"
   - M√™mes d√©clencheurs que le backend

3. **Ajoutez les √©tapes suivantes :**
   - R√©cup√©rer le code
   - Installer Node.js 18 avec `actions/setup-node@v4`
     - Activez le cache npm : `cache: 'npm'`
     - Sp√©cifiez le chemin : `cache-dependency-path: frontend/package-lock.json`
   - Installer les d√©pendances : `cd frontend && npm ci`
   - Lancer les tests : `cd frontend && npm test -- --run`
   - V√©rifier le build : `cd frontend && npm run build`

4. **Testez localement :**

   ```bash
   cd frontend
   npm test -- --run
   npm run build
   ```

5. **Poussez et v√©rifiez :**

   ```bash
   git add .github/workflows/frontend.yml
   git commit -m "ci: add frontend workflow"
   git push origin main
   ```

### ‚úÖ R√©sultat attendu

Vous devriez voir **2 workflows en parall√®le** :

```
‚úÖ Backend Tests
‚úÖ Frontend Tests
```

### üí° Note importante

**`npm ci` vs `npm install` :**

- `npm ci` : Installe exactement ce qui est dans `package-lock.json` (d√©terministe)
- `npm install` : Peut mettre √† jour les versions (moins fiable pour CI)

---

## ‚úçÔ∏è Exercice 3 : D√©boguer un √âchec

### Objectif

Apprendre √† lire les logs et corriger les erreurs de workflow.

### Instructions

1. **Introduisez volontairement un bug dans `backend/tests/test_api.py` :**

   ```python
   def test_health_check(client):
       response = client.get("/health")
       assert response.status_code == 200
       assert response.json()["status"] == "BROKEN"  # ‚ùå Faux expr√®s !
   ```

2. **Poussez le bug :**

   ```bash
   git add backend/tests/test_api.py
   git commit -m "test: intentional failure for learning"
   git push origin main
   ```

3. **Observez l'√©chec sur GitHub Actions :**
   - Allez dans "Actions"
   - Cliquez sur le workflow ‚ùå rouge
   - Cliquez sur l'√©tape "Run tests"

4. **Analysez les logs :**
   - Quel test √©choue ?
   - √Ä quelle ligne ?
   - Quelle est l'erreur exacte ?

5. **Reproduisez localement :**

   ```bash
   cd backend
   uv run pytest tests/test_api.py::test_health_check -v
   ```

6. **Corrigez le bug :**

   ```python
   assert response.json()["status"] == "healthy"  # ‚úÖ Correct
   ```

7. **V√©rifiez localement puis poussez :**

   ```bash
   uv run pytest tests/test_api.py::test_health_check -v
   git add backend/tests/test_api.py
   git commit -m "fix: correct health check assertion"
   git push origin main
   ```

### ‚úÖ Le√ßon apprise

**Si √ßa passe localement, √ßa passera sur GitHub !**

---

## ‚úçÔ∏è Exercice 4 : Optimiser avec le Cache

### Objectif

R√©duire le temps d'ex√©cution de 2-3 minutes √† ~30 secondes en utilisant le cache.

### Instructions

1. **Modifiez `.github/workflows/backend.yml`**

2. **Ajoutez une √©tape de cache APR√àS l'installation de Python :**

   ```yaml
   - name: üíæ Cache UV dependencies
     uses: actions/cache@v4
     with:
       path: ~/.cache/uv
       key: ${{ runner.os }}-uv-${{ hashFiles('backend/pyproject.toml', 'backend/uv.lock') }}
       restore-keys: |
         ${{ runner.os }}-uv-
   ```

3. **Comprenez la cl√© du cache :**
   - `${{ runner.os }}` : OS (Linux)
   - `${{ hashFiles(...) }}` : Hash des fichiers de d√©pendances
   - Le cache change seulement si vous ajoutez/retirez une d√©pendance

4. **Testez en poussant deux fois :**

   ```bash
   # Premier push - cache vide
   git add .github/workflows/backend.yml
   git commit -m "ci: add UV cache"
   git push

   # Deuxi√®me push - cache restaur√©
   echo "# Test cache" >> README.md
   git add README.md
   git commit -m "test: trigger workflow"
   git push
   ```

5. **Observez la diff√©rence :**
   - 1√®re ex√©cution : "Cache not found" ‚Üí t√©l√©charge tout (~2 min)
   - 2√®me ex√©cution : "Cache restored" ‚Üí utilise le cache (~30 sec)

### ‚úÖ R√©sultat

**Temps gagn√© : ~2 minutes par build !** ‚ö°

---

## ‚úçÔ∏è Exercice 5 : Workflows R√©utilisables

### Objectif

Cr√©er un pipeline CI global qui orchestre backend et frontend.

### Instructions

1. **Rendez vos workflows r√©utilisables :**

   Dans `backend.yml` et `frontend.yml`, ajoutez `workflow_call` aux d√©clencheurs :

   ```yaml
   on:
     push:
       branches: [main]
     pull_request:
       branches: [main]
     workflow_call:  # ‚ú® Nouveau !
   ```

2. **Cr√©ez `.github/workflows/ci-pipeline.yml` :**

   ```yaml
   name: CI Pipeline

   on:
     push:
       branches: [main]
     pull_request:
       branches: [main]

   jobs:
     backend:
       name: Backend Tests
       uses: ./.github/workflows/backend.yml

     frontend:
       name: Frontend Tests
       uses: ./.github/workflows/frontend.yml

     summary:
       name: All Tests Passed
       needs: [backend, frontend]
       runs-on: ubuntu-latest
       steps:
         - name: üéâ Success
           run: echo "üéâ Tous les tests sont pass√©s !"
   ```

3. **Poussez et observez :**

   ```bash
   git add .github/workflows/
   git commit -m "ci: add reusable workflows and pipeline"
   git push origin main
   ```

### ‚úÖ R√©sultat

Vous verrez maintenant **3 workflows** :

```
‚úÖ Backend Tests
‚úÖ Frontend Tests
‚úÖ CI Pipeline (r√©sum√© global)
```

Le job `summary` attend que backend **ET** frontend soient termin√©s avant de s'ex√©cuter.

---

## ‚úçÔ∏è Exercice 6 : S√©parer Tests Unitaires et E2E

### Objectif

Ex√©cuter les tests rapides (unitaires) sur toutes les branches, mais les tests lents (E2E) seulement sur `main`.

### Instructions

**Partie 1 : Marquer les tests E2E**

1. **Dans `backend/tests/conftest.py`, ajoutez :**

   ```python
   def pytest_configure(config):
       """Enregistre les markers personnalis√©s"""
       config.addinivalue_line(
           "markers",
           "e2e: mark test as end-to-end test (slow)"
       )
   ```

2. **Dans `backend/tests/test_api.py`, cr√©ez un test E2E :**

   ```python
   import pytest

   @pytest.mark.e2e
   def test_complete_task_lifecycle(client):
       """Test E2E : CRUD complet d'une t√¢che."""
       # Cr√©er
       response = client.post("/tasks", json={
           "title": "Test E2E",
           "description": "Test complet"
       })
       assert response.status_code == 201
       task_id = response.json()["id"]

       # Lire
       response = client.get(f"/tasks/{task_id}")
       assert response.status_code == 200

       # Mettre √† jour
       response = client.put(f"/tasks/{task_id}", json={
           "title": "Updated",
           "description": "Modified"
       })
       assert response.status_code == 200

       # Supprimer
       response = client.delete(f"/tasks/{task_id}")
       assert response.status_code == 204

       # V√©rifier suppression
       response = client.get(f"/tasks/{task_id}")
       assert response.status_code == 404
   ```

3. **Testez localement les diff√©rentes commandes :**

   ```bash
   cd backend
   # Tests unitaires seulement
   uv run pytest -v -m "not e2e"

   # Tests E2E seulement
   uv run pytest -v -m "e2e"

   # Tous les tests
   uv run pytest -v
   ```

**Partie 2 : Cr√©er le workflow s√©par√©**

4. **Cr√©ez `.github/workflows/backend-split.yml` avec 2 jobs :**

   - **Job 1 : unit-tests** (toujours)
     - Ex√©cute : `pytest -v -m "not e2e"`

   - **Job 2 : e2e-tests** (seulement sur main)
     - Ajoute la condition : `if: github.ref == 'refs/heads/main'`
     - Ex√©cute : `pytest -v -m "e2e"`

5. **Testez avec une Pull Request :**

   ```bash
   git checkout -b test/split-tests
   echo "# Test" >> README.md
   git add .
   git commit -m "test: verify E2E don't run on PR"
   git push origin test/split-tests
   ```

### ‚úÖ R√©sultat attendu

- **Sur PR** : Seulement "Unit Tests" s'ex√©cute
- **Sur main** : "Unit Tests" **ET** "E2E Tests" s'ex√©cutent

---

## ‚úçÔ∏è Exercice 7 : Cha√Æne de Jobs Frontend

### Objectif

Cr√©er une cha√Æne Lint ‚Üí Test ‚Üí Build pour optimiser le feedback.

### Instructions

1. **Cr√©ez `.github/workflows/frontend-chain.yml` avec 3 jobs :**

   **Job 1 : lint**
   - Installe les d√©pendances
   - Ex√©cute : `npm run lint`

   **Job 2 : test**
   - D√©pend de `lint` avec `needs: lint`
   - Installe les d√©pendances
   - Ex√©cute : `npm test -- --run`

   **Job 3 : build**
   - D√©pend de `test` avec `needs: test`
   - Installe les d√©pendances
   - Ex√©cute : `npm run build`
   - Upload les artifacts avec `actions/upload-artifact@v4` :

     ```yaml
     - name: üì§ Upload build artifacts
       uses: actions/upload-artifact@v4
       with:
         name: frontend-build
         path: frontend/dist/
     ```

2. **Poussez et observez :**

   ```bash
   git add .github/workflows/frontend-chain.yml
   git commit -m "ci: add frontend chain"
   git push origin main
   ```

### ‚úÖ Avantages

- Si lint √©choue ‚Üí tests et build ne s'ex√©cutent pas
- Feedback plus rapide (lint = 10s vs build = 2min)
- Build artifacts disponibles pour t√©l√©chargement

---

## ‚úçÔ∏è Exercice 8 : Badges de Status

### Objectif

Afficher le statut des workflows dans votre README.

### Instructions

1. **Modifiez `README.md` et ajoutez au d√©but :**

   ```markdown
   # TaskFlow API

   ![Backend Tests](https://github.com/VOTRE_NOM/VOTRE_REPO/workflows/Backend%20Tests/badge.svg)
   ![Frontend Tests](https://github.com/VOTRE_NOM/VOTRE_REPO/workflows/Frontend%20Tests/badge.svg)
   ![CI Pipeline](https://github.com/VOTRE_NOM/VOTRE_REPO/workflows/CI%20Pipeline/badge.svg)
   ```

2. **Remplacez :**
   - `VOTRE_NOM` ‚Üí Votre username GitHub
   - `VOTRE_REPO` ‚Üí Nom de votre repo

3. **Poussez :**

   ```bash
   git add README.md
   git commit -m "docs: add CI badges"
   git push origin main
   ```

### ‚úÖ R√©sultat

Sur GitHub, vous verrez des badges qui se mettent √† jour automatiquement :

```
‚úÖ Backend Tests  ‚úÖ Frontend Tests  ‚úÖ CI Pipeline
```

---

## üìã R√©capitulatif

F√©licitations ! Vous avez maintenant :

‚úÖ **Exercice 1** : Workflow backend automatis√©
‚úÖ **Exercice 2** : Workflow frontend automatis√©
‚úÖ **Exercice 3** : Comp√©tences en d√©bogage de workflows
‚úÖ **Exercice 4** : Cache UV pour optimiser les builds
‚úÖ **Exercice 5** : Pipeline CI global avec workflows r√©utilisables
‚úÖ **Exercice 6** : S√©paration tests unitaires / E2E
‚úÖ **Exercice 7** : Cha√Æne de jobs frontend optimis√©e
‚úÖ **Exercice 8** : Badges de status dans le README

**Temps total estim√© :** 4-5 heures

---

## üêõ Erreurs Fr√©quentes

### ‚ùå `uv: command not found`

**Cause :** UV n'est pas dans le PATH
**Solution :** Ajoutez `echo "$HOME/.cargo/bin" >> $GITHUB_PATH`

### ‚ùå Tests qui passent localement mais √©chouent sur GitHub

**Causes possibles :**

1. Variable d'environnement manquante
2. D√©pendance syst√®me manquante
3. Timezone diff√©rente

**D√©boguer :** Reproduisez exactement les m√™mes commandes localement

### ‚ùå Cache qui ne fonctionne pas

**Cause :** Mauvaise cl√© de cache
**Solution :** V√©rifiez que `hashFiles()` pointe vers les bons fichiers

---

## üéÅ BONUS : Workflow Java (Optionnel)

**Pour les √©tudiants qui ont fait les exercices Java du TP 1.**

### Objectif

Tester automatiquement les 3 projets Java (calculator, string-utils, bank-account).

### Instructions

1. **Cr√©ez `.github/workflows/java.yml` :**

```yaml
name: Java Tests (Optional)

on:
  push:
    branches: [main]
    paths:
      - 'java-exercises/**'
  pull_request:
    branches: [main]
    paths:
      - 'java-exercises/**'
  workflow_dispatch:

jobs:
  test:
    name: Test Java Exercises
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: ‚òï Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: üßÆ Test Calculator
        working-directory: java-exercises/calculator
        run: |
          javac -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar *.java
          java -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar org.junit.runner.JUnitCore CalculatorTest

      - name: üìù Test String Utils
        working-directory: java-exercises/string-utils
        run: |
          javac -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar *.java
          java -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar org.junit.runner.JUnitCore StringUtilsTest

      - name: üè¶ Test Bank Account
        working-directory: java-exercises/bank-account
        run: |
          javac -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar *.java
          java -cp .:../lib/junit-4.13.2.jar:../lib/hamcrest-core-1.3.jar org.junit.runner.JUnitCore BankAccountTest
```

### Nouveaux concepts

**`paths:` - D√©clenchement conditionnel**

```yaml
on:
  push:
    paths:
      - 'java-exercises/**'
```

Le workflow ne s'ex√©cute que si vous modifiez des fichiers Java.

**`workflow_dispatch:` - Lancement manuel**
Vous pouvez lancer le workflow manuellement depuis l'onglet Actions.

**`working-directory:` - R√©pertoire de travail**

```yaml
- name: Test Calculator
  working-directory: java-exercises/calculator
```

Plus propre que d'utiliser `cd` dans chaque commande.

### Test

**Option 1 : Modifier un fichier Java**

```bash
echo "// Test CI" >> java-exercises/calculator/Calculator.java
git add java-exercises/
git commit -m "test: trigger Java workflow"
git push
```

**Option 2 : Lancement manuel**

1. Allez dans "Actions" ‚Üí "Java Tests (Optional)"
2. Cliquez sur "Run workflow"
3. S√©lectionnez "main" et cliquez "Run workflow"
